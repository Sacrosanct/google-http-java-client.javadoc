<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Fri Oct 21 13:19:48 EDT 2011 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Google HTTP Client Library for Java 1.5.3-beta"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/yanivi/programs/jdiff-1.1.1/jdiff.jar:/home/yanivi/programs/jdiff-1.1.1/xerces.jar -d /home/yanivi/hg/google-http-java-client/javadoc/default/1.5.3-beta/jdiff -classpath /usr/share/ant/lib/ant-launcher.jar:/usr/share/java/xmlParserAPIs.jar:/usr/share/java/xercesImpl.jar:/usr/share/ant/lib/ant-jdepend.jar:/usr/share/ant/lib/ant-apache-resolver.jar:/usr/share/ant/lib/ant-jmf.jar:/usr/share/ant/lib/ant-apache-regexp.jar:/usr/share/ant/lib/ant-apache-bsf.jar:/usr/share/ant/lib/ant-commons-logging.jar:/usr/share/ant/lib/ant-apache-log4j.jar:/usr/share/ant/lib/ant-swing.jar:/usr/share/ant/lib/ant-nodeps.jar:/usr/share/ant/lib/ant-trax.jar:/usr/share/ant/lib/ant-javamail.jar:/usr/share/ant/lib/ant-jsch.jar:/usr/share/ant/lib/ant-commons-net.jar:/usr/share/ant/lib/ant-junit.jar:/usr/share/ant/lib/ant-apache-bcel.jar:/usr/share/ant/lib/ant-apache-oro.jar:/usr/share/ant/lib/ant-antlr.jar:/usr/share/ant/lib/ant.jar:/usr/local/buildtools/java/jdk6-google-v4/lib/tools.jar -sourcepath /tmp/google-http-java-client/1.5.3-beta/google-http-client/src/main/java:/tmp/google-http-java-client/1.5.3-beta/google-http-client-extensions/src/main/java:/tmp/google-http-java-client/1.5.3-beta/google-http-client-extensions-android2/src/main/java:/tmp/google-http-java-client/1.5.3-beta/google-http-client-extensions-android3/src/main/java -apiname Google HTTP Client Library for Java 1.5.3-beta -baseURI http://www.w3.org -apidir /home/yanivi/hg/google-http-java-client/javadoc/default/1.5.3-beta/jdiff -source 1.5 -->
<package name="com.google.api.client.extensions.android2">
  <!-- start class com.google.api.client.extensions.android2.AndroidHttp -->
  <class name="AndroidHttp" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AndroidHttp"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newCompatibleTransport" return="com.google.api.client.http.HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new thread-safe HTTP transport instance that is compatible with Android SDKs prior to
 Gingerbread.
 <p>
 Don't use this for Android applications that anyway require Gingerbread. Instead just call
 {@code new NetHttpTransport()}.
 </p>
 <p>
 Prior to Gingerbread, the {@link HttpURLConnection} implementation was buggy, and the Apache
 HTTP Client was preferred. However, starting with Gingerbread, the {@link HttpURLConnection}
 implementation bugs were fixed, and is now better supported than the Apache HTTP Client. There
 is no guarantee that Apache HTTP transport will continue to work in future SDKs. Therefore,
 this method uses {@link NetHttpTransport} for Gingerbread or higher, and otherwise
 {@link ApacheHttpTransport}.
 </p>]]>
      </doc>
    </method>
    <method name="isGingerbreadOrHigher" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the SDK version is Gingerbread (2.3) or higher.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utilities for Android HTTP transport.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.android2.AndroidHttp -->
</package>
<package name="com.google.api.client.extensions.android3.json">
  <!-- start class com.google.api.client.extensions.android3.json.AndroidJsonFactory -->
  <class name="AndroidJsonFactory" extends="com.google.api.client.json.JsonFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AndroidJsonFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="enc" type="com.google.api.client.json.JsonEncoding"/>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON library implementation based on GSON.

 <p>
 Implementation is thread-safe, and sub-classes must be thread-safe. For maximum efficiency,
 applications should use a single globally-shared instance of the JSON factory.
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.android3.json.AndroidJsonFactory -->
  <!-- start class com.google.api.client.extensions.android3.json.AndroidJsonGenerator -->
  <class name="AndroidJsonGenerator" extends="com.google.api.client.json.JsonGenerator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be made package-private in 1.6)">
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeEndArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeEndObject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFieldName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNull"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.math.BigInteger"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.math.BigDecimal"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedValue" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStartArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStartObject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON serializer implementation based on GSON.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.4
 @author Yaniv Inbar
 @deprecated (scheduled to be made package-private in 1.6)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.android3.json.AndroidJsonGenerator -->
  <!-- start class com.google.api.client.extensions.android3.json.AndroidJsonParser -->
  <class name="AndroidJsonParser" extends="com.google.api.client.json.JsonParser"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be made package-private in 1.6)">
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCurrentName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCurrentToken" return="com.google.api.client.json.JsonToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getByteValue" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getShortValue" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIntValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFloatValue" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBigIntegerValue" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDecimalValue" return="java.math.BigDecimal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDoubleValue" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLongValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextToken" return="com.google.api.client.json.JsonToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipChildren" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON serializer implementation based on GSON.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.4
 @author Yaniv Inbar
 @deprecated (scheduled to be made package-private in 1.6)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.android3.json.AndroidJsonParser -->
</package>
<package name="com.google.api.client.extensions.appengine.http.urlfetch">
  <!-- start class com.google.api.client.extensions.appengine.http.urlfetch.UrlFetchTransport -->
  <class name="UrlFetchTransport" extends="com.google.api.client.http.HttpTransport"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="UrlFetchTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Thread-safe HTTP transport for Google App Engine based on <a
 href="http://code.google.com/appengine/docs/java/urlfetch/">URL Fetch</a>.

 <p>
 Implementation is thread-safe. For maximum efficiency, applications should use a single
 globally-shared instance of the HTTP transport.
 </p>

 <p>
 URL Fetch is only available on Google App Engine (not on any other Java environment), and is the
 underlying HTTP transport used for App Engine. Their implementation of {@link HttpURLConnection}
 is simply an abstraction layer on top of URL Fetch. By implementing a transport that directly
 uses URL Fetch, we can optimize the behavior slightly, and can potentially take advantage of
 features in URL Fetch that are not available in {@link HttpURLConnection}. Furthermore, there is
 currently a serious bug in how HTTP headers are processed in the App Engine implementation of
 {@link HttpURLConnection}, which we are able to avoid using this implementation. Therefore, this
 is the recommended transport to use on App Engine.
 </p>

 @since 1.2
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.appengine.http.urlfetch.UrlFetchTransport -->
</package>
<package name="com.google.api.client.http">
  <!-- start class com.google.api.client.http.AbstractHttpContent -->
  <class name="AbstractHttpContent" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="AbstractHttpContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default implementation returns {@code null}, but subclasses may override.]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Default implementation calls {@link #computeLength()} once and caches it for future
 invocations, but subclasses may override.]]>
      </doc>
    </method>
    <method name="computeLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the content length or less than zero if not known.

 <p>
 Subclasses may override, but by default this computes the length by calling
 {@link #writeTo(OutputStream)} with an output stream that does not process the bytes written,
 but only retains the count of bytes. If {@link #retrySupported()} is {@code false}, it will
 instead return {@code -1}.
 </p>]]>
      </doc>
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default implementation returns {@code true}, but subclasses may override.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract implementation of an HTTP content with typical options.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.5
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.AbstractHttpContent -->
  <!-- start class com.google.api.client.http.AbstractInputStreamContent -->
  <class name="AbstractInputStreamContent" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="AbstractInputStreamContent"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #AbstractInputStreamContent(String)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use {@link #AbstractInputStreamContent(String)}]]>
      </doc>
    </constructor>
    <constructor name="AbstractInputStreamContent" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param type Content type or {@code null} for none
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an input stream for the specific implementation type of
 {@link AbstractInputStreamContent}. If the specific implementation will return {@code true} for
 {@link #retrySupported()} this should be a factory function which will create a new
 {@link InputStream} from the source data whenever invoked.]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setEncoding" return="com.google.api.client.http.AbstractInputStreamContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encoding" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content encoding (for example {@code "gzip"}) or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setType" return="com.google.api.client.http.AbstractInputStreamContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content type or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputStream" type="java.io.InputStream"/>
      <param name="outputStream" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the content provided by the given source input stream into the given destination output
 stream.
 <p>
 The input stream is guaranteed to be closed at the end of the method.
 </p>
 <p>
 Sample use:

 <pre><code>
  static void downloadMedia(HttpResponse response, File file)
      throws IOException {
    FileOutputStream out = new FileOutputStream(file);
    try {
      AbstractInputStreamContent.copy(response.getContent(), out);
    } finally {
      out.close();
    }
  }
 </code></pre>
 </p>

 @param inputStream source input stream
 @param outputStream destination output stream]]>
      </doc>
    </method>
    <field name="type" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getType} or {@link #setType}">
      <doc>
      <![CDATA[Content type or {@code null} for none.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getType} or {@link #setType}]]>
      </doc>
    </field>
    <field name="encoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getEncoding} or
             {@link #setEncoding}">
      <doc>
      <![CDATA[Content encoding (for example {@code "gzip"}) or {@code null} for none.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getEncoding} or
             {@link #setEncoding}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes HTTP request content from an input stream into an output stream.

 <p>
 The {@link #type} field is required. Subclasses should implement the {@link #getLength()},
 {@link #getInputStream()}, and {@link #retrySupported()} for their specific type of input stream.
 <p>

 <p>
 Implementations don't need to be thread-safe.
 </p>

 @since 1.4
 @author moshenko@google.com (Jacob Moshenko)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.AbstractInputStreamContent -->
  <!-- start class com.google.api.client.http.ByteArrayContent -->
  <class name="ByteArrayContent" extends="com.google.api.client.http.AbstractInputStreamContent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ByteArrayContent" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #ByteArrayContent(String, byte[])}">
      <doc>
      <![CDATA[@param array Data source for creating input streams.
 @deprecated (scheduled to be removed in 1.6) Use {@link #ByteArrayContent(String, byte[])}]]>
      </doc>
    </constructor>
    <constructor name="ByteArrayContent" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #fromString(String, String)}">
      <doc>
      <![CDATA[Create an instance from the byte contents of the string. This assumes that the string is
 encoded in UTF-8 and uses {@code Strings.toBytesUtf8()} to perform the conversion.

 @param contentString String to use as the source data for creating input streams
 @deprecated (scheduled to be removed in 1.6) Use {@link #fromString(String, String)}]]>
      </doc>
    </constructor>
    <constructor name="ByteArrayContent"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@code new ByteArrayContent(null, new
             byte[]{})}">
      <doc>
      <![CDATA[Create an instance with no data.

 @deprecated (scheduled to be removed in 1.6) Use {@code new ByteArrayContent(null, new
             byte[]{})}]]>
      </doc>
    </constructor>
    <constructor name="ByteArrayContent" type="java.lang.String, byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param type content type or {@code null} for none
 @param array byte array content
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="fromString" return="com.google.api.client.http.ByteArrayContent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
      <param name="contentString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a new instance with the UTF-8 encoding (using {@code Strings.toBytesUtf8()}) of the
 given content string.
 <p>
 Sample use:
 </p>

 <pre>
 <code>
  static void setJsonContent(HttpRequest request, String json) {
    request.setContent(ByteArrayContent.fromString("application/json", json));
  }
 </code>
 </pre>

 @param type content type or {@code null} for none
 @param contentString content string
 @since 1.5]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="setEncoding" return="com.google.api.client.http.ByteArrayContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encoding" type="java.lang.String"/>
    </method>
    <method name="setType" return="com.google.api.client.http.ByteArrayContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Concrete implementation of {@link AbstractInputStreamContent} that generates repeatable input
 streams based on the contents of byte array.

 <p>
 Sample use:
 </p>

 <pre>
 <code>
  static void setJsonContent(HttpRequest request, byte[] json) {
    request.setContent(new ByteArrayContent("application/json", json));
  }
 </code>
 </pre>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.4
 @author moshenko@google.com (Jacob Moshenko)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.ByteArrayContent -->
  <!-- start class com.google.api.client.http.FileContent -->
  <class name="FileContent" extends="com.google.api.client.http.AbstractInputStreamContent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileContent" type="java.io.File"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #FileContent(String, File)}">
      <doc>
      <![CDATA[@param file file
 @deprecated (scheduled to be removed in 1.6) Use {@link #FileContent(String, File)}]]>
      </doc>
    </constructor>
    <constructor name="FileContent" type="java.lang.String, java.io.File"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param type Content type or {@code null} for none
 @param file file
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
    </method>
    <method name="getFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the file.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setEncoding" return="com.google.api.client.http.FileContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encoding" type="java.lang.String"/>
    </method>
    <method name="setType" return="com.google.api.client.http.FileContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Concrete implementation of {@link AbstractInputStreamContent} that generates repeatable input
 streams based on the contents of a file.

 <p>
 Sample use:
 </p>

 <pre>
 <code>
  private static void setRequestJpegContent(HttpRequest request, File jpegFile) {
    request.setContent(new FileContent("image/jpeg", jpegFile));
  }
 </code>
 </pre>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.4
 @author moshenko@google.com (Jacob Moshenko)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.FileContent -->
  <!-- start class com.google.api.client.http.GenericUrl -->
  <class name="GenericUrl" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GenericUrl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="GenericUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs from an encoded URL.
 <p>
 Any known query parameters with pre-defined fields as data keys will be parsed based on their
 data type. Any unrecognized query parameter will always be parsed as a string.

 @param encodedUrl encoded URL, including any existing query parameters that should be parsed
 @throws IllegalArgumentException if URL has a syntax error]]>
      </doc>
    </constructor>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.http.GenericUrl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the scheme (lowercase), for example {@code "https"}.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setScheme"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="scheme" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the scheme (lowercase), for example {@code "https"}.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getHost" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the host, for example {@code "www.google.com"}.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setHost"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the host, for example {@code "www.google.com"}.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the port number or {@code -1} if undefined, for example {@code 443}.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setPort"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="port" type="int"/>
      <doc>
      <![CDATA[Returns the port number or {@code -1} if undefined, for example {@code 443}.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getPathParts" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the decoded path component by parts with each part separated by a {@code '/'} or {@code
 null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setPathParts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathParts" type="java.util.List&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Sets the decoded path component by parts with each part separated by a {@code '/'} or {@code
 null} for none.

 <p>
 For example {@code "/m8/feeds/contacts/default/full"} is represented by {@code "", "m8",
 "feeds", "contacts", "default", "full"}.
 </p>

 <p>
 Use {@link #appendRawPath(String)} to append to the path, which ensures that no extra slash is
 added.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getFragment" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the fragment component or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setFragment"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="fragment" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the fragment component or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="build" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the string representation of the URL, including the path specified by
 {@link #pathParts} and the query parameters specified by this generic URL.]]>
      </doc>
    </method>
    <method name="getFirst" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the first query parameter value for the given query parameter name.

 @param name query parameter name
 @return first query parameter value]]>
      </doc>
    </method>
    <method name="getAll" return="java.util.Collection&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns all query parameter values for the given query parameter name.

 @param name query parameter name
 @return unmodifiable collection of query parameter values (possibly empty)]]>
      </doc>
    </method>
    <method name="getRawPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw encoded path computed from the {@link #pathParts}.

 @return raw encoded path computed from the {@link #pathParts} or {@code null} if
         {@link #pathParts} is {@code null}]]>
      </doc>
    </method>
    <method name="setRawPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedPath" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@link #pathParts} from the given raw encoded path.

 @param encodedPath raw encoded path or {@code null} to set {@link #pathParts} to {@code null}]]>
      </doc>
    </method>
    <method name="appendRawPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedPath" type="java.lang.String"/>
      <doc>
      <![CDATA[Appends the given raw encoded path to the current {@link #pathParts}, setting field only if it
 is {@code null} or empty.
 <p>
 The last part of the {@link #pathParts} is merged with the first part of the path parts
 computed from the given encoded path. Thus, if the current raw encoded path is {@code "a"}, and
 the given encoded path is {@code "b"}, then the resulting raw encoded path is {@code "ab"}.

 @param encodedPath raw encoded path or {@code null} to ignore]]>
      </doc>
    </method>
    <method name="toPathParts" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedPath" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the decoded path parts for the given encoded path.

 @param encodedPath slash-prefixed encoded path, for example {@code
        "/m8/feeds/contacts/default/full"}
 @return decoded path parts, with each part assumed to be preceded by a {@code '/'}, for example
         {@code "", "m8", "feeds", "contacts", "default", "full"}, or {@code null} for {@code
         null} or {@code ""} input]]>
      </doc>
    </method>
    <field name="scheme" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getScheme} or {@link #setScheme}">
      <doc>
      <![CDATA[Scheme (lowercase), for example {@code "https"}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getScheme} or {@link #setScheme}]]>
      </doc>
    </field>
    <field name="host" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getHost} or {@link #setHost}">
      <doc>
      <![CDATA[Host, for example {@code "www.google.com"}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getHost} or {@link #setHost}]]>
      </doc>
    </field>
    <field name="port" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getPort} or {@link #setPort}">
      <doc>
      <![CDATA[Port number or {@code -1} if undefined, for example {@code 443}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getPort} or {@link #setPort}]]>
      </doc>
    </field>
    <field name="pathParts" type="java.util.List&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getPathParts} or
             {@link #setPathParts}">
      <doc>
      <![CDATA[Decoded path component by parts with each part separated by a {@code '/'} or {@code null} for
 none, for example {@code "/m8/feeds/contacts/default/full"} is represented by {@code "", "m8",
 "feeds", "contacts", "default", "full"}.
 <p>
 Use {@link #appendRawPath(String)} to append to the path, which ensures that no extra slash is
 added.
 </p>

 @deprecated (scheduled to be made private in 1.6) Use {@link #getPathParts} or
             {@link #setPathParts}]]>
      </doc>
    </field>
    <field name="fragment" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getFragment} or
             {@link #setFragment}">
      <doc>
      <![CDATA[Fragment component or {@code null} for none.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getFragment} or
             {@link #setFragment}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[URL builder in which the query parameters are specified as generic data key/value pairs, based on
 the specification <a href="http://tools.ietf.org/html/rfc3986">RFC 3986: Uniform Resource
 Identifier (URI)</a>.

 <p>
 The query parameters are specified with the data key name as the parameter name, and the data
 value as the parameter value. Subclasses can declare fields for known query parameters using the
 {@link Key} annotation. {@code null} parameter names are not allowed, but {@code null} query
 values are allowed.
 </p>

 <p>
 Query parameter values are parsed using {@link UrlEncodedParser#parse(String, Object)}.
 </p>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.GenericUrl -->
  <!-- start interface com.google.api.client.http.HttpContent -->
  <interface name="HttpContent"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the content length or less than zero if not known.]]>
      </doc>
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content encoding (for example {@code "gzip"}) or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type or {@code null} for none.]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the content to the given output stream.]]>
      </doc>
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether or not retry is supported on this content type.

 @since 1.4]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Serializes HTTP request content into an output stream.

 <p>
 Implementations don't need to be thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpContent -->
  <!-- start interface com.google.api.client.http.HttpExecuteInterceptor -->
  <interface name="HttpExecuteInterceptor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Invoked at the start of {@link HttpRequest#execute()} before executing the HTTP request.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[HTTP request execute interceptor to intercept the start of {@link HttpRequest#execute()} before
 executing the HTTP request.

 <p>
 For example, this might be used to sign a request for OAuth:
 </p>

 <pre>
  public class OAuthSigner implements HttpExecuteInterceptor {
    public void intercept(HttpRequest request) throws IOException {
      // sign request...
    }
  }
 </pre>

 <p>
 Sample usage with a request factory:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    final OAuthSigner signer = new OAuthSigner(...);
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) {
        request.interceptor = signer;
      }
    });
  }
 </pre>

 <p>
 If you have a custom request execute interceptor, use this more complex example:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    final OAuthSigner signer = new OAuthSigner(...);
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) {
        request.interceptor = new HttpExecuteInterceptor() {
          public void intercept(HttpRequest request) throws IOException {
            signer.intercept(request);
          }
        };
      }
    });
  }
 </pre>

 <p>
 Implementations should normally be thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpExecuteInterceptor -->
  <!-- start class com.google.api.client.http.HttpHeaders -->
  <class name="HttpHeaders" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HttpHeaders"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="clone" return="com.google.api.client.http.HttpHeaders"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAccept" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Accept"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setAccept"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="accept" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Accept"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getAcceptEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Accept-Encoding"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setAcceptEncoding"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="acceptEncoding" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Accept-Encoding"} header or {@code null} for none.

 <p>
 By default, this is {@code "gzip"}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getAuthorization" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Authorization"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setAuthorization"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="authorization" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Authorization"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getCacheControl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Cache-Control"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setCacheControl"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="cacheControl" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Cache-Control"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getContentEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Content-Encoding"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContentEncoding"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="contentEncoding" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Content-Encoding"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getContentLength" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Content-Length"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContentLength"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="contentLength" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Content-Length"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getContentMD5" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Content-MD5"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContentMD5"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="contentMD5" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Content-MD5"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getContentRange" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Content-Range"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContentRange"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="contentRange" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Content-Range"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Content-Type"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContentType"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Content-Type"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getDate" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Date"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setDate"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="date" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Date"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getETag" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "ETag"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setETag"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="etag" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "ETag"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getExpires" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Expires"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setExpires"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="expires" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Expires"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getIfModifiedSince" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "If-Modified-Since"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setIfModifiedSince"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="ifModifiedSince" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "If-Modified-Since"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getIfMatch" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "If-Match"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setIfMatch"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="ifMatch" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "If-Match"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getIfNoneMatch" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "If-None-Match"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setIfNoneMatch"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="ifNoneMatch" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "If-None-Match"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getIfUnmodifiedSince" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "If-Unmodified-Since"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setIfUnmodifiedSince"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="ifUnmodifiedSince" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "If-Unmodified-Since"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getLastModified" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Last-Modified"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setLastModified"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="lastModified" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Last-Modified"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getLocation" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Location"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setLocation"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Location"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getMimeVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "MIME-Version"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setMimeVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="mimeVersion" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "MIME-Version"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getRange" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Range"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setRange"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Range"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getRetryAfter" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "Retry-After"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setRetryAfter"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="retryAfter" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Retry-After"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getUserAgent" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "User-Agent"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setUserAgent"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="userAgent" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "User-Agent"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getAuthenticate" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code "WWW-Authenticate"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setAuthenticate"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="authenticate" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "WWW-Authenticate"} header or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setBasicAuthentication"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="username" type="java.lang.String"/>
      <param name="password" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@link #authorization} header as specified in <a
 href="http://tools.ietf.org/html/rfc2617#section-2">Basic Authentication Scheme</a>.

 @since 1.2]]>
      </doc>
    </method>
    <field name="accept" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getAccept} or {@link #setAccept}">
      <doc>
      <![CDATA[{@code "Accept"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getAccept} or {@link #setAccept}]]>
      </doc>
    </field>
    <field name="acceptEncoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getAcceptEncoding} or
             {@link #setAcceptEncoding}">
      <doc>
      <![CDATA[{@code "Accept-Encoding"} header. By default, this is {@code "gzip"}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getAcceptEncoding} or
             {@link #setAcceptEncoding}]]>
      </doc>
    </field>
    <field name="authorization" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getAuthorization} or
             {@link #setAuthorization}">
      <doc>
      <![CDATA[{@code "Authorization"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getAuthorization} or
             {@link #setAuthorization}]]>
      </doc>
    </field>
    <field name="cacheControl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getCacheControl} or
             {@link #setCacheControl}">
      <doc>
      <![CDATA[{@code "Cache-Control"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getCacheControl} or
             {@link #setCacheControl}]]>
      </doc>
    </field>
    <field name="contentEncoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContentEncoding} or
             {@link #setContentEncoding}">
      <doc>
      <![CDATA[{@code "Content-Encoding"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContentEncoding} or
             {@link #setContentEncoding}]]>
      </doc>
    </field>
    <field name="contentLength" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContentLength} or
             {@link #setContentLength}">
      <doc>
      <![CDATA[{@code "Content-Length"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContentLength} or
             {@link #setContentLength}]]>
      </doc>
    </field>
    <field name="contentMD5" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContentMD5} or
             {@link #setContentMD5}">
      <doc>
      <![CDATA[{@code "Content-MD5"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContentMD5} or
             {@link #setContentMD5}]]>
      </doc>
    </field>
    <field name="contentRange" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContentRange} or
             {@link #setContentRange}">
      <doc>
      <![CDATA[{@code "Content-Range"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContentRange} or
             {@link #setContentRange}]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContentType} or
             {@link #setContentType}">
      <doc>
      <![CDATA[{@code "Content-Type"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContentType} or
             {@link #setContentType}]]>
      </doc>
    </field>
    <field name="date" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getDate} or {@link #setDate}">
      <doc>
      <![CDATA[{@code "Date"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getDate} or {@link #setDate}]]>
      </doc>
    </field>
    <field name="etag" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getETag} or {@link #setETag}">
      <doc>
      <![CDATA[{@code "ETag"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getETag} or {@link #setETag}]]>
      </doc>
    </field>
    <field name="expires" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getExpires} or
             {@link #setExpires}">
      <doc>
      <![CDATA[{@code "Expires"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getExpires} or
             {@link #setExpires}]]>
      </doc>
    </field>
    <field name="ifModifiedSince" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getIfModifiedSince} or
             {@link #setIfModifiedSince}">
      <doc>
      <![CDATA[{@code "If-Modified-Since"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getIfModifiedSince} or
             {@link #setIfModifiedSince}]]>
      </doc>
    </field>
    <field name="ifMatch" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getIfMatch} or
             {@link #setIfMatch}">
      <doc>
      <![CDATA[{@code "If-Match"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getIfMatch} or
             {@link #setIfMatch}]]>
      </doc>
    </field>
    <field name="ifNoneMatch" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getIfNoneMatch} or
             {@link #setIfNoneMatch}">
      <doc>
      <![CDATA[{@code "If-None-Match"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getIfNoneMatch} or
             {@link #setIfNoneMatch}]]>
      </doc>
    </field>
    <field name="ifUnmodifiedSince" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getIfUnmodifiedSince} or
             {@link #setIfUnmodifiedSince}">
      <doc>
      <![CDATA[{@code "If-Unmodified-Since"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getIfUnmodifiedSince} or
             {@link #setIfUnmodifiedSince}]]>
      </doc>
    </field>
    <field name="lastModified" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getLastModified} or
             {@link #setLastModified}">
      <doc>
      <![CDATA[{@code "Last-Modified"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getLastModified} or
             {@link #setLastModified}]]>
      </doc>
    </field>
    <field name="location" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getLocation} or
             {@link #setLocation}">
      <doc>
      <![CDATA[{@code "Location"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getLocation} or
             {@link #setLocation}]]>
      </doc>
    </field>
    <field name="mimeVersion" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getMimeVersion} or
             {@link #setMimeVersion}">
      <doc>
      <![CDATA[{@code "MIME-Version"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getMimeVersion} or
             {@link #setMimeVersion}]]>
      </doc>
    </field>
    <field name="range" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getRange} or {@link #setRange}">
      <doc>
      <![CDATA[{@code "Range"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getRange} or {@link #setRange}]]>
      </doc>
    </field>
    <field name="retryAfter" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getRetryAfter} or
             {@link #setRetryAfter}">
      <doc>
      <![CDATA[{@code "Retry-After"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getRetryAfter} or
             {@link #setRetryAfter}]]>
      </doc>
    </field>
    <field name="userAgent" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getUserAgent} or
             {@link #setUserAgent}">
      <doc>
      <![CDATA[{@code "User-Agent"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getUserAgent} or
             {@link #setUserAgent}]]>
      </doc>
    </field>
    <field name="authenticate" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getAuthenticate} or
             {@link #setAuthenticate}">
      <doc>
      <![CDATA[{@code "WWW-Authenticate"} header.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getAuthenticate} or
             {@link #setAuthenticate}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Stores HTTP headers used in an HTTP request or response, as defined in <a
 href="http://tools.ietf.org/html/rfc2616#section-14">Header Field Definitions</a>.

 <p>
 {@code null} is not allowed as a name or value of a header. Names are case-insensitive.
 </p>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpHeaders -->
  <!-- start class com.google.api.client.http.HttpMethod -->
  <class name="HttpMethod" extends="java.lang.Enum&lt;com.google.api.client.http.HttpMethod&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.http.HttpMethod[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.http.HttpMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[HTTP request method.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpMethod -->
  <!-- start interface com.google.api.client.http.HttpParser -->
  <interface name="HttpParser"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type.]]>
      </doc>
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses the given HTTP response into a new instance of the the given data class of key/value
 pairs.
 <p>
 How the parsing is performed is not restricted by this interface, and is instead defined by the
 concrete implementation. Implementations should check
 {@link HttpResponse#isSuccessStatusCode()} to know whether they are parsing a success or error
 response.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Parses HTTP response content into an data class of key/value pairs.

 <p>
 Implementations should normally be thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpParser -->
  <!-- start class com.google.api.client.http.HttpRequest -->
  <class name="HttpRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getTransport" return="com.google.api.client.http.HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP transport.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getMethod" return="com.google.api.client.http.HttpMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP request method.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setMethod" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="com.google.api.client.http.HttpMethod"/>
      <doc>
      <![CDATA[Sets the HTTP request method.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getUrl" return="com.google.api.client.http.GenericUrl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP request URL.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setUrl" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <doc>
      <![CDATA[Sets the HTTP request URL.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getContent" return="com.google.api.client.http.HttpContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP request content or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContent" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <doc>
      <![CDATA[Sets the HTTP request content or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getEnableGZipContent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether to enable gzip compression of HTTP content.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setEnableGZipContent" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enableGZipContent" type="boolean"/>
      <doc>
      <![CDATA[Returns whether to enable gzip compression of HTTP content.

 <p>
 By default it is {@code false}.
 </p>

 <p>
 To avoid the overhead of GZip compression for small content, one may want to set this to {@code
 true} only for {@link HttpContent#getLength()} above a certain limit. For example:
 </p>

 <pre>
  public static class MyInterceptor implements HttpExecuteInterceptor {
    public void intercept(HttpRequest request) throws IOException {
      if (request.getContent() != null && request.getContent().getLength() >= 256) {
        request.setEnableGZipContent(true);
      }
    }
  }
 </pre>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getDisableContentLogging" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether to disable request content logging during {@link #execute()} (unless
 {@link Level#ALL} is loggable which forces all logging).

 @since 1.5]]>
      </doc>
    </method>
    <method name="setDisableContentLogging" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="disableContentLogging" type="boolean"/>
      <doc>
      <![CDATA[Returns whether to disable request content logging during {@link #execute()} (unless
 {@link Level#ALL} is loggable which forces all logging).

 <p>
 Useful for example if content has sensitive data such as an authentication information.
 Defaults to {@code false}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getConnectTimeout" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the timeout in milliseconds to establish a connection or {@code 0} for an infinite
 timeout.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setConnectTimeout" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="connectTimeout" type="int"/>
      <doc>
      <![CDATA[Sets the timeout in milliseconds to establish a connection or {@code 0} for an infinite
 timeout.

 <p>
 By default it is 20000 (20 seconds).
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getReadTimeout" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the timeout in milliseconds to read data from an established connection or {@code 0}
 for an infinite timeout.

 <p>
 By default it is 20000 (20 seconds).
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="setReadTimeout" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readTimeout" type="int"/>
      <doc>
      <![CDATA[Sets the timeout in milliseconds to read data from an established connection or {@code 0} for
 an infinite timeout.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getHeaders" return="com.google.api.client.http.HttpHeaders"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP request headers.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setHeaders" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headers" type="com.google.api.client.http.HttpHeaders"/>
      <doc>
      <![CDATA[Sets the HTTP request headers.

 <p>
 By default, this is a new unmodified instance of {@link HttpHeaders}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getResponseHeaders" return="com.google.api.client.http.HttpHeaders"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP response headers.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setResponseHeaders" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="responseHeaders" type="com.google.api.client.http.HttpHeaders"/>
      <doc>
      <![CDATA[Sets the HTTP response headers.

 <p>
 By default, this is a new unmodified instance of {@link HttpHeaders}.
 </p>

 <p>
 For example, this can be used if you want to use a subclass of {@link HttpHeaders} called
 MyHeaders to process the response:
 </p>

 <pre>
  static String executeAndGetValueOfSomeCustomHeader(HttpRequest request) {
    MyHeaders responseHeaders = new MyHeaders();
    request.responseHeaders = responseHeaders;
    HttpResponse response = request.execute();
    return responseHeaders.someCustomHeader;
  }
 </pre>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getInterceptor" return="com.google.api.client.http.HttpExecuteInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP request execute interceptor to intercept the start of {@link #execute()}
 (before executing the HTTP request) or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setInterceptor" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptor" type="com.google.api.client.http.HttpExecuteInterceptor"/>
      <doc>
      <![CDATA[Sets the HTTP request execute interceptor to intercept the start of {@link #execute()} (before
 executing the HTTP request) or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getUnsuccessfulResponseHandler" return="com.google.api.client.http.HttpUnsuccessfulResponseHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP unsuccessful (non-2XX) response handler or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setUnsuccessfulResponseHandler" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unsuccessfulResponseHandler" type="com.google.api.client.http.HttpUnsuccessfulResponseHandler"/>
      <doc>
      <![CDATA[Returns the HTTP unsuccessful (non-2XX) response handler or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getNumberOfRetries" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of retries that will be allowed to execute as the result of an
 {@link HttpUnsuccessfulResponseHandler} before being terminated or {@code 0} to not retry
 requests.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setNumberOfRetries" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="numRetries" type="int"/>
      <doc>
      <![CDATA[Returns the number of retries that will be allowed to execute as the result of an
 {@link HttpUnsuccessfulResponseHandler} before being terminated or {@code 0} to not retry
 requests.

 <p>
 The default value is {@code 10}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="addParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="com.google.api.client.http.HttpParser"/>
      <doc>
      <![CDATA[Adds an HTTP response content parser.
 <p>
 If there is already a previous parser defined for this new parser (as defined by
 {@link #getParser(String)} then the previous parser will be removed.
 </p>

 @since 1.4]]>
      </doc>
    </method>
    <method name="getParser" return="com.google.api.client.http.HttpParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the HTTP response content parser to use for the given content type or {@code null} if
 none is defined.

 @param contentType content type or {@code null} for {@code null} result
 @return HTTP response content parser or {@code null} for {@code null} input
 @since 1.4]]>
      </doc>
    </method>
    <method name="execute" return="com.google.api.client.http.HttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Execute the HTTP request and returns the HTTP response.
 <p>
 Note that regardless of the returned status code, the HTTP response content has not been parsed
 yet, and must be parsed by the calling code.
 <p>
 Almost all details of the request and response are logged if {@link Level#CONFIG} is loggable.
 The only exception is the value of the {@code Authorization} header which is only logged if
 {@link Level#ALL} is loggable.

 @return HTTP response for an HTTP success code
 @throws HttpResponseException for an HTTP error code
 @see HttpResponse#isSuccessStatusCode()]]>
      </doc>
    </method>
    <method name="normalizeMediaType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mediaType" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the normalized media type without parameters of the form {@code type "/" subtype"} as
 specified in <a href="http://tools.ietf.org/html/rfc2616#section-3.7">Media Types</a>.

 @param mediaType unnormalized media type with possible parameters or {@code null} for {@code
        null} result
 @return normalized media type without parameters or {@code null} for {@code null} input
 @since 1.4]]>
      </doc>
    </method>
    <field name="USER_AGENT_SUFFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[User agent suffix for all requests.

 <p>
 Includes a {@code "(gzip)"} suffix in case the server -- as Google's servers may do -- checks
 the {@code User-Agent} header to try to detect if the client accepts gzip-encoded responses.
 </p>

 @since 1.4]]>
      </doc>
    </field>
    <field name="interceptor" type="com.google.api.client.http.HttpExecuteInterceptor"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getInterceptor} or
             {@link #setInterceptor}">
      <doc>
      <![CDATA[HTTP request execute interceptor to intercept the start of {@link #execute()} (before executing
 the HTTP request) or {@code null} for none.

 @since 1.4
 @deprecated (scheduled to be made private in 1.6) Use {@link #getInterceptor} or
             {@link #setInterceptor}]]>
      </doc>
    </field>
    <field name="headers" type="com.google.api.client.http.HttpHeaders"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getHeaders} or
             {@link #setHeaders}">
      <doc>
      <![CDATA[HTTP request headers.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getHeaders} or
             {@link #setHeaders}]]>
      </doc>
    </field>
    <field name="responseHeaders" type="com.google.api.client.http.HttpHeaders"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getResponseHeaders} or
             {@link #setResponseHeaders}">
      <doc>
      <![CDATA[HTTP response headers.
 <p>
 For example, this can be used if you want to use a subclass of {@link HttpHeaders} called
 MyHeaders to process the response:
 </p>

 <pre>
  static String executeAndGetValueOfSomeCustomHeader(HttpRequest request) {
    MyHeaders responseHeaders = new MyHeaders();
    request.responseHeaders = responseHeaders;
    HttpResponse response = request.execute();
    return responseHeaders.someCustomHeader;
  }
 </pre>

 @since 1.4
 @deprecated (scheduled to be made private in 1.6) Use {@link #getResponseHeaders} or
             {@link #setResponseHeaders}]]>
      </doc>
    </field>
    <field name="numRetries" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getNumberOfRetries} or
             {@link #setNumberOfRetries}">
      <doc>
      <![CDATA[Set the number of retries that will be allowed to execute as the result of an
 {@link HttpUnsuccessfulResponseHandler} before being terminated or {@code 0} to not retry
 requests. The default value is {@code 10}.

 @since 1.4
 @deprecated (scheduled to be made private in 1.6) Use {@link #getNumberOfRetries} or
             {@link #setNumberOfRetries}]]>
      </doc>
    </field>
    <field name="disableContentLogging" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getDisableContentLogging} or
             {@link #setDisableContentLogging}">
      <doc>
      <![CDATA[Whether to disable request content logging during {@link #execute()} (unless {@link Level#ALL}
 is loggable which forces all logging).
 <p>
 Useful for example if content has sensitive data such as an authentication information.
 Defaults to {@code false}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getDisableContentLogging} or
             {@link #setDisableContentLogging}]]>
      </doc>
    </field>
    <field name="content" type="com.google.api.client.http.HttpContent"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContent} or
             {@link #setContent}">
      <doc>
      <![CDATA[HTTP request content or {@code null} for none.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContent} or
             {@link #setContent}]]>
      </doc>
    </field>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getTransport}">
      <doc>
      <![CDATA[HTTP transport.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getTransport}]]>
      </doc>
    </field>
    <field name="method" type="com.google.api.client.http.HttpMethod"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getMethod} or {@link #setMethod}">
      <doc>
      <![CDATA[HTTP request method.

 @since 1.3
 @deprecated (scheduled to be made private in 1.6) Use {@link #getMethod} or {@link #setMethod}]]>
      </doc>
    </field>
    <field name="url" type="com.google.api.client.http.GenericUrl"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getUrl} or {@link #setUrl}">
      <doc>
      <![CDATA[HTTP request URL.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getUrl} or {@link #setUrl}]]>
      </doc>
    </field>
    <field name="connectTimeout" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getConnectTimeout} or
             {@link #setConnectTimeout}">
      <doc>
      <![CDATA[Timeout in milliseconds to establish a connection or {@code 0} for an infinite timeout.
 <p>
 By default it is 20 seconds.
 </p>

 @since 1.4
 @deprecated (scheduled to be made private in 1.6) Use {@link #getConnectTimeout} or
             {@link #setConnectTimeout}]]>
      </doc>
    </field>
    <field name="readTimeout" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getReadTimeout} or
             {@link #setReadTimeout}">
      <doc>
      <![CDATA[Timeout in milliseconds to read data from an established connection or {@code 0} for an
 infinite timeout.
 <p>
 By default it is 20 seconds.
 </p>

 @since 1.4
 @deprecated (scheduled to be made private in 1.6) Use {@link #getReadTimeout} or
             {@link #setReadTimeout}]]>
      </doc>
    </field>
    <field name="unsuccessfulResponseHandler" type="com.google.api.client.http.HttpUnsuccessfulResponseHandler"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getUnsuccessfulResponseHandler}
             or {@link #setUnsuccessfulResponseHandler}">
      <doc>
      <![CDATA[HTTP unsuccessful (non-2XX) response handler or {@code null} for none.

 @since 1.4
 @deprecated (scheduled to be made private in 1.6) Use {@link #getUnsuccessfulResponseHandler}
             or {@link #setUnsuccessfulResponseHandler}]]>
      </doc>
    </field>
    <field name="enableGZipContent" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getEnableGZipContent} or
             {@link #setEnableGZipContent}">
      <doc>
      <![CDATA[Whether to enable gzip compression of HTTP content ({@code false} by default).

 @since 1.4
 @deprecated (scheduled to be made private in 1.6) Use {@link #getEnableGZipContent} or
             {@link #setEnableGZipContent}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP request.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpRequest -->
  <!-- start class com.google.api.client.http.HttpRequestFactory -->
  <class name="HttpRequestFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getTransport" return="com.google.api.client.http.HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP transport.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getInitializer" return="com.google.api.client.http.HttpRequestInitializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP request initializer or {@code null} for none.

 <p>
 This initializer is invoked before setting its method, URL, or content.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="buildRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="com.google.api.client.http.HttpMethod"/>
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a request for the given HTTP method, URL, and content.

 @param method HTTP request method
 @param url HTTP request URL or {@code null} for none
 @param content HTTP request content or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code DELETE} request for the given URL.

 @param url HTTP request URL or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code GET} request for the given URL.

 @param url HTTP request URL or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code POST} request for the given URL and content.

 @param url HTTP request URL or {@code null} for none
 @param content HTTP request content or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code PUT} request for the given URL and content.

 @param url HTTP request URL or {@code null} for none
 @param content HTTP request content or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code PATCH} request for the given URL and content.

 @param url HTTP request URL or {@code null} for none
 @param content HTTP request content or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code HEAD} request for the given URL.

 @param url HTTP request URL or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getTransport()}">
      <doc>
      <![CDATA[HTTP transport.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getTransport()}]]>
      </doc>
    </field>
    <field name="initializer" type="com.google.api.client.http.HttpRequestInitializer"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getInitializer()}">
      <doc>
      <![CDATA[HTTP request initializer or {@code null} for none.

 <p>
 This initializer is invoked before setting its {@link HttpRequest#method},
 {@link HttpRequest#url}, or {@link HttpRequest#content}.
 </p>

 @deprecated (scheduled to be made private in 1.6) Use {@link #getInitializer()}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Thread-safe light-weight HTTP request factory layer on top of the HTTP transport that has an
 optional {@link HttpRequestInitializer HTTP request initializer} for initializing requests.

 <p>
 For example, to use a particular authorization header across all requests, use:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) throws IOException {
        request.getHeaders().setAuthorization("...");
      }
    });
  }
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpRequestFactory -->
  <!-- start interface com.google.api.client.http.HttpRequestInitializer -->
  <interface name="HttpRequestInitializer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Initializes a request.

 @param request HTTP request]]>
      </doc>
    </method>
    <doc>
    <![CDATA[HTTP request initializer.

 <p>
 For example, this might be used to disable request timeouts:
 </p>

 <pre>
  public class DisableTimeout implements HttpRequestInitializer {
    public void initialize(HttpRequest request) {
      request.connectTimeout = request.readTimeout = 0;
    }
  }
 </pre>

 <p>
 Sample usage with a request factory:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    return transport.createRequestFactory(new DisableTimeout());
  }
 </pre>

 <p>
 If you have a custom request initializer, use this more complex example:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    final DisableTimeout disableTimeout = new DisableTimeout();
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) {
        disableTimeout.initialize(request);
      }
    });
  }
 </pre>

 <p>
 Implementations should normally be thread-safe.
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpRequestInitializer -->
  <!-- start class com.google.api.client.http.HttpResponse -->
  <class name="HttpResponse" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getDisableContentLogging" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets whether to disable response content logging during {@link #getContent()} (unless
 {@link Level#ALL} is loggable which forces all logging).

 @since 1.5]]>
      </doc>
    </method>
    <method name="setDisableContentLogging" return="com.google.api.client.http.HttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="disableContentLogging" type="boolean"/>
      <doc>
      <![CDATA[Sets whether to disable response content logging during {@link #getContent()} (unless
 {@link Level#ALL} is loggable which forces all logging).

 <p>
 Useful for example if content has sensitive data such as an authentication token. Defaults to
 {@code false}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getContentEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content encoding or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getHeaders" return="com.google.api.client.http.HttpHeaders"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP response headers.

 @since 1.5]]>
      </doc>
    </method>
    <method name="isSuccessStatusCode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether received a successful HTTP status code {@code >= 200 && < 300} (see
 {@link #getStatusCode()}).

 @since 1.5]]>
      </doc>
    </method>
    <method name="getStatusCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP status code.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getStatusMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP status message or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getTransport" return="com.google.api.client.http.HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP transport.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP request.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getContent" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the content of the HTTP response.
 <p>
 The result is cached, so subsequent calls will be fast.

 @return input stream content of the HTTP response or {@code null} for none
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="ignore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes the the content of the HTTP response from {@link #getContent()}, ignoring any content.]]>
      </doc>
    </method>
    <method name="disconnect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Disconnect using {@link LowLevelHttpResponse#disconnect()}.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getParser" return="com.google.api.client.http.HttpParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP response content parser to use for the content type of this HTTP response or
 {@code null} for none.]]>
      </doc>
    </method>
    <method name="parseAs" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses the content of the HTTP response from {@link #getContent()} and reads it into a data
 class of key/value pairs using the parser returned by {@link #getParser()} .

 @return parsed data class or {@code null} for no content
 @throws IOException I/O exception
 @throws IllegalArgumentException if no parser is defined for the given content type or if there
         is no content type defined in the HTTP response]]>
      </doc>
    </method>
    <method name="parseAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses the content of the HTTP response from {@link #getContent()} and reads it into a string.
 <p>
 Since this method returns {@code ""} for no content, a simpler check for no content is to check
 if {@link #getContent()} is {@code null}.

 @return parsed string or {@code ""} for no content
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="isSuccessStatusCode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statusCode" type="int"/>
      <doc>
      <![CDATA[Returns whether the given HTTP response status code is a success code {@code >= 200 and < 300}.]]>
      </doc>
    </method>
    <field name="contentEncoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContentEncoding}">
      <doc>
      <![CDATA[Content encoding or {@code null}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContentEncoding}]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContentType}">
      <doc>
      <![CDATA[Content type or {@code null} for none.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContentType}]]>
      </doc>
    </field>
    <field name="headers" type="com.google.api.client.http.HttpHeaders"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getHeaders}">
      <doc>
      <![CDATA[HTTP headers.
 <p>
 If a header name is used for multiple headers, only the last one is retained. The value is
 initialized to {@link HttpRequest#responseHeaders} before being parsed from the actual HTTP
 response headers.
 <p>

 @deprecated (scheduled to be made private in 1.6) Use {@link #getHeaders}]]>
      </doc>
    </field>
    <field name="isSuccessStatusCode" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #isSuccessStatusCode()}">
      <doc>
      <![CDATA[Whether received a successful status code {@code >= 200 && < 300}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #isSuccessStatusCode()}]]>
      </doc>
    </field>
    <field name="statusCode" type="int"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getStatusCode}">
      <doc>
      <![CDATA[Status code.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getStatusCode}]]>
      </doc>
    </field>
    <field name="statusMessage" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getStatusMessage}">
      <doc>
      <![CDATA[Status message or {@code null}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getStatusMessage}]]>
      </doc>
    </field>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getTransport}">
      <doc>
      <![CDATA[HTTP transport.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getTransport}]]>
      </doc>
    </field>
    <field name="request" type="com.google.api.client.http.HttpRequest"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getRequest}">
      <doc>
      <![CDATA[HTTP request.

 @since 1.4
 @deprecated (scheduled to be made private in 1.6) Use {@link #getRequest}]]>
      </doc>
    </field>
    <field name="disableContentLogging" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getDisableContentLogging} or
             {@link #setDisableContentLogging}">
      <doc>
      <![CDATA[Whether to disable response content logging during {@link #getContent()} (unless
 {@link Level#ALL} is loggable which forces all logging).
 <p>
 Useful for example if content has sensitive data such as an authentication token. Defaults to
 {@code false}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getDisableContentLogging} or
             {@link #setDisableContentLogging}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP response.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpResponse -->
  <!-- start class com.google.api.client.http.HttpResponseException -->
  <class name="HttpResponseException" extends="java.io.IOException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HttpResponseException" type="com.google.api.client.http.HttpResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param response HTTP response]]>
      </doc>
    </constructor>
    <method name="getResponse" return="com.google.api.client.http.HttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP response.

 @since 1.5]]>
      </doc>
    </method>
    <method name="computeMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <doc>
      <![CDATA[Returns an exception message to use for the given HTTP response.]]>
      </doc>
    </method>
    <field name="response" type="com.google.api.client.http.HttpResponse"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getResponse}">
      <doc>
      <![CDATA[HTTP response.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getResponse}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Exception thrown when an error status code is detected in an HTTP response.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpResponseException -->
  <!-- start class com.google.api.client.http.HttpTransport -->
  <class name="HttpTransport" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createRequestFactory" return="com.google.api.client.http.HttpRequestFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new instance of an HTTP request factory based on this HTTP transport.

 @return new instance of an HTTP request factory
 @since 1.4]]>
      </doc>
    </method>
    <method name="createRequestFactory" return="com.google.api.client.http.HttpRequestFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="initializer" type="com.google.api.client.http.HttpRequestInitializer"/>
      <doc>
      <![CDATA[Returns a new instance of an HTTP request factory based on this HTTP transport with the given
 HTTP request initializer.

 @param initializer HTTP request initializer or {@code null} for none
 @return new instance of an HTTP request factory
 @since 1.4]]>
      </doc>
    </method>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this HTTP transport implementation supports the {@code HEAD} request method.
 <p>
 Default implementation returns {@code false}.
 </p>

 @since 1.3]]>
      </doc>
    </method>
    <method name="supportsPatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this HTTP transport implementation supports the {@code PATCH} request method.
 <p>
 Default implementation returns {@code false}.
 </p>

 @since 1.3]]>
      </doc>
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code DELETE} request.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code GET} request.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code HEAD} request. Won't be called if {@link #supportsHead()} returns {@code false}
 .
 <p>
 Default implementation throws an {@link UnsupportedOperationException}.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code PATCH} request. Won't be called if {@link #supportsPatch()} returns {@code
 false}.
 <p>
 Default implementation throws an {@link UnsupportedOperationException}.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code POST} request.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code PUT} request.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Default implementation does nothing, but subclasses may override to possibly release allocated
 system resources or close connections.

 @throws IOException I/O exception
 @since 1.4]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thread-safe abstract HTTP transport.

 <p>
 Implementation is thread-safe, and sub-classes must be thread-safe. For maximum efficiency,
 applications should use a single globally-shared instance of the HTTP transport.
 </p>

 <p>
 The recommended concrete implementation HTTP transport library to use depends on what environment
 you are running in:
 </p>
 <ul>
 <li>Google App Engine: use {@code com.google.api.client.appengine.UrlFetchTransport}.
 <ul>
 <li>{@code com.google.api.client.apache.ApacheHttpTransport} doesn't work on App Engine because
 the Apache HTTP Client opens its own sockets (though in theory there are ways to hack it to work
 on App Engine that might work).</li>
 <li>{@code com.google.api.client.javanet.NetHttpTransport} is discouraged due to a bug in the App
 Engine SDK itself in how it parses HTTP headers in the response.</li>
 </ul>
 </li>
 <li>Android:
 <ul>
 <li>Starting with SDK 2.3, strongly recommended to use {@code
 com.google.api.client.javanet.NetHttpTransport}. Their Apache HTTP Client implementation is not
 as well maintained.</li>
 <li>For SDK 2.2 and earlier, use {@code com.google.api.client.apache.ApacheHttpTransport}. {@code
 com.google.api.client.javanet.NetHttpTransport} is not recommended due to some bugs in the
 Android SDK implementation of HttpURLConnection.</li>
 </ul>
 </li>
 <li>Other Java environments
 <ul>
 <li>{@code com.google.api.client.javanet.NetHttpTransport} is based on the HttpURLConnection
 built into the Java SDK, so it is normally the preferred choice.</li>
 <li>{@code com.google.api.client.apache.ApacheHttpTransport} is a good choice for users of the
 Apache HTTP Client, especially if you need some of the configuration options available in that
 library.</li>
 </ul>
 </li>
 </ul>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpTransport -->
  <!-- start interface com.google.api.client.http.HttpUnsuccessfulResponseHandler -->
  <interface name="HttpUnsuccessfulResponseHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handleResponse" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="retrySupported" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Handler that will be invoked when an abnormal response is received. There are a few simple
 rules that one must follow:
 <ul>
 <li>If you modify the request object or modify its execute interceptors in a way that should
 resolve the error, you must return true to issue a retry.</li>
 <li>Do not read from the content stream, this will prevent the eventual end user from having
 access to it.</li>
 </ul>

 @param request Request object that can be read from for context or modified before retry
 @param response Response to process
 @param retrySupported Whether there will actually be a retry if this handler return {@code
        true}. Some handlers may want to have an effect only when there will actually be a retry
        after they handle their event (e.g. a handler that implements exponential backoff).
 @return Whether or not this handler has made a change that will require the request to be
         re-sent.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface which handles abnormal HTTP responses (in other words not 2XX).

 <p>
 For example, this might be used to refresh an OAuth 2 token:
 </p>

 <pre>
  public static class RefreshTokenHandler implements HttpUnsuccessfulResponseHandler {
    public boolean handleResponse(
        HttpRequest request, HttpResponse response, boolean retrySupported) throws IOException {
      if (response.statusCode == 401) {
        refreshToken();
      }
      return false;
    }
  }
 </pre>

 <p>
 Sample usage with a request factory:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    final RefreshTokenHandler handler = new RefreshTokenHandler();
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) {
        request.unsuccessfulResponseHandler = handler;
      }
    });
  }
 </pre>

 <p>
 If you have a custom unsuccessful response handler, use this more complex example:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    final RefreshTokenHandler handler = new RefreshTokenHandler();
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) {
        request.unsuccessfulResponseHandler = new HttpUnsuccessfulResponseHandler() {
          public boolean handleResponse(
              HttpRequest request, HttpResponse response, boolean retrySupported)
              throws IOException {
            return handler.handleResponse(request, response, retrySupported);
          }
        };
      }
    });
  }
 </pre>

 <p>
 Implementations should normally be thread-safe.
 </p>

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpUnsuccessfulResponseHandler -->
  <!-- start class com.google.api.client.http.InputStreamContent -->
  <class name="InputStreamContent" extends="com.google.api.client.http.AbstractInputStreamContent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="InputStreamContent"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use
             {@link #InputStreamContent(String, InputStream)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use
             {@link #InputStreamContent(String, InputStream)}]]>
      </doc>
    </constructor>
    <constructor name="InputStreamContent" type="java.lang.String, java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param type Content type or {@code null} for none
 @param inputStream Input stream to read from
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setEncoding" return="com.google.api.client.http.InputStreamContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encoding" type="java.lang.String"/>
    </method>
    <method name="setType" return="com.google.api.client.http.InputStreamContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
    </method>
    <method name="setLength"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Sets the content length or less than zero if not known.

 <p>
 Defaults to {@code -1}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <field name="length" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getLength} or {@link #setLength}">
      <doc>
      <![CDATA[Content length or less than zero if not known. Defaults to {@code -1}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getLength} or {@link #setLength}]]>
      </doc>
    </field>
    <field name="inputStream" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getInputStream}">
      <doc>
      <![CDATA[Input stream to read from.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getInputStream}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Concrete implementation of {@link AbstractInputStreamContent} that simply handles the transfer of
 data from an input stream to an output stream. This should only be used for streams that can not
 be re-opened and retried. If you have a stream that it is possible to recreate please create a
 new subclass of {@link AbstractInputStreamContent}.

 <p>
 The input stream is guaranteed to be closed at the end of {@link #writeTo(OutputStream)}.
 </p>

 <p>
 Sample use with a URL:

 <pre>
 <code>
  private static void setRequestJpegContent(HttpRequest request, URL jpegUrl) throws IOException {
    request.setContent(new InputStreamContent("image/jpeg", jpegUrl.openStream()));
  }
 </code>
 </pre>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.InputStreamContent -->
  <!-- start class com.google.api.client.http.LowLevelHttpRequest -->
  <class name="LowLevelHttpRequest" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LowLevelHttpRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addHeader"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a header to the HTTP request.
 <p>
 Note that multiple headers of the same name need to be supported, in which case
 {@link #addHeader} will be called for each instance of the header.

 @param name header name
 @param value header value]]>
      </doc>
    </method>
    <method name="setContent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sets the HTTP request content.

 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="setTimeout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="connectTimeout" type="int"/>
      <param name="readTimeout" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sets the connection and read timeouts.

 <p>
 Default implementation does nothing, but subclasses should normally override.
 </p>

 @param connectTimeout timeout in milliseconds to establish a connection or {@code 0} for an
        infinite timeout
 @param readTimeout Timeout in milliseconds to read data from an established connection or
        {@code 0} for an infinite timeout
 @since 1.4]]>
      </doc>
    </method>
    <method name="execute" return="com.google.api.client.http.LowLevelHttpResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes the request and returns a low-level HTTP response object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Low-level HTTP request.

 <p>
 This allows providing a different implementation of the HTTP request that is more compatible with
 the Java environment used.
 </p>

 <p>
 Implementation has no fields and therefore thread-safe, but sub-classes are not necessarily
 thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.LowLevelHttpRequest -->
  <!-- start class com.google.api.client.http.LowLevelHttpResponse -->
  <class name="LowLevelHttpResponse" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LowLevelHttpResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContent" return="java.io.InputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the HTTP response content input stream or {@code null} for none.

 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="getContentEncoding" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content encoding (for example {@code "gzip"}) or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getContentLength" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content length or {@code 0} for none.]]>
      </doc>
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getStatusLine" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the response status line or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getStatusCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the response status code or {@code 0} for none.]]>
      </doc>
    </method>
    <method name="getReasonPhrase" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP reason phrase or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getHeaderCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of HTTP response headers.
 <p>
 Note that multiple headers of the same name need to be supported, in which case each header
 value is treated as a separate header.]]>
      </doc>
    </method>
    <method name="getHeaderName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the HTTP response header name at the given zero-based index.]]>
      </doc>
    </method>
    <method name="getHeaderValue" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the HTTP response header value at the given zero-based index.]]>
      </doc>
    </method>
    <method name="disconnect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Default implementation does nothing, but subclasses may override to attempt to abort the
 connection or release allocated system resources for this connection.

 @throws IOException I/O exception
 @since 1.4]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Low-level HTTP response.

 <p>
 This allows providing a different implementation of the HTTP response that is more compatible
 with the Java environment used.
 </p>

 <p>
 Implementation has no fields and therefore thread-safe, but sub-classes are not necessarily
 thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.LowLevelHttpResponse -->
  <!-- start class com.google.api.client.http.MultipartRelatedContent -->
  <class name="MultipartRelatedContent" extends="com.google.api.client.http.AbstractHttpContent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MultipartRelatedContent"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use
             {@link #MultipartRelatedContent(HttpContent, HttpContent...)} and
             {@link #forRequest(HttpRequest)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be made private in 1.6) Use
             {@link #MultipartRelatedContent(HttpContent, HttpContent...)} and
             {@link #forRequest(HttpRequest)}]]>
      </doc>
    </constructor>
    <constructor name="MultipartRelatedContent" type="com.google.api.client.http.HttpContent, com.google.api.client.http.HttpContent[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param firstPart first HTTP content part
 @param otherParts other HTTP content parts
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="forRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <doc>
      <![CDATA[Sets this multi-part content as the content for the given HTTP request, and set the
 {@link HttpHeaders#setMimeVersion(String) MIME version header} to {@code "1.0"}.

 @param request HTTP request
 @since 1.5]]>
      </doc>
    </method>
    <method name="forRequest" return="com.google.api.client.http.MultipartRelatedContent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use
             {@link #MultipartRelatedContent(HttpContent, HttpContent...)} and
             {@link #forRequest(HttpRequest)}">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <param name="parts" type="com.google.api.client.http.HttpContent[]"/>
      <doc>
      <![CDATA[Returns a new multi-part content serializer as the content for the given HTTP request.

 <p>
 It also sets the {@link HttpHeaders#getMimeVersion MIME version} of
 {@link HttpRequest#getHeaders() headers} to {@code "1.0"}.
 </p>

 @param request HTTP request
 @param parts HTTP content parts
 @return new multi-part content serializer
 @deprecated (scheduled to be made private in 1.6) Use
             {@link #MultipartRelatedContent(HttpContent, HttpContent...)} and
             {@link #forRequest(HttpRequest)}]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="computeLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBoundary" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the boundary string to use.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setBoundary" return="com.google.api.client.http.MultipartRelatedContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="boundary" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the boundary string to use.

 <p>
 Defaults to {@code "END_OF_PART"}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getParts" return="java.util.Collection&lt;com.google.api.client.http.HttpContent&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP content parts.

 @since 1.5]]>
      </doc>
    </method>
    <field name="boundary" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getBoundary} or
             {@link #setBoundary}">
      <doc>
      <![CDATA[Boundary string to use. By default, it is {@code "END_OF_PART"}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getBoundary} or
             {@link #setBoundary}]]>
      </doc>
    </field>
    <field name="parts" type="java.util.Collection&lt;com.google.api.client.http.HttpContent&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getParts}">
      <doc>
      <![CDATA[Collection of HTTP content parts.

 <p>
 By default, it is an empty list.
 </p>

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getParts}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes MIME Multipart/Related content as specified by <a
 href="http://tools.ietf.org/html/rfc2387">RFC 2387: The MIME Multipart/Related Content-type</a>.
 <p>
 Limitations:
 <ul>
 <li>No support of parameters other than {@code "boundary"}</li>
 <li>No support for specifying headers for each content part</li>
 <li>The content type of each part is required, so {@link HttpContent#getType()} must not be
 {@code null}</li>
 </ul>
 </p>
 <p>
 Use {@link #forRequest(HttpRequest)} to construct. For example:

 <pre><code>
  static void setMediaWithMetadataContent(
      HttpRequest request, AtomContent atomContent, InputStreamContent imageContent) {
    MultipartRelatedContent.forRequest(request, atomContent, imageContent);
  }
 </code></pre>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.1
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.MultipartRelatedContent -->
  <!-- start class com.google.api.client.http.UrlEncodedContent -->
  <class name="UrlEncodedContent" extends="com.google.api.client.http.AbstractHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UrlEncodedContent"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #UrlEncodedContent(Object)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use {@link #UrlEncodedContent(Object)}]]>
      </doc>
    </constructor>
    <constructor name="UrlEncodedContent" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param data key name/value data or {@code null} for none]]>
      </doc>
    </constructor>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setType" return="com.google.api.client.http.UrlEncodedContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content type or {@code null} for none.

 <p>
 Defaults to {@link UrlEncodedParser#CONTENT_TYPE}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getData" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key name/value data or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setData" return="com.google.api.client.http.UrlEncodedContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the key name/value data or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getType} or {@link #setType}">
      <doc>
      <![CDATA[Content type. Default value is {@link UrlEncodedParser#CONTENT_TYPE}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getType} or {@link #setType}]]>
      </doc>
    </field>
    <field name="data" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getData} or
             {@link #setData}">
      <doc>
      <![CDATA[Key name/value data or {@code null} for none.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getData} or
             {@link #setData}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Implements support for HTTP form content encoding serialization of type {@code
 application/x-www-form-urlencoded} as specified in the <a href=
 "http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.4.1">HTML 4.0 Specification</a>.

 <p>
 Sample usage:
 </p>

 <pre>
 <code>
  static void setContent(HttpRequest request, Object item) {
    request.setContent(new UrlEncodedContent(item));
  }
 </code>
 </pre>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.UrlEncodedContent -->
  <!-- start class com.google.api.client.http.UrlEncodedParser -->
  <class name="UrlEncodedParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <constructor name="UrlEncodedParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UrlEncodedParser" type="java.lang.String, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param contentType content type
 @param disableContentLogging whether to disable response content logging (unless
        {@link Level#ALL} is loggable which forces all logging)
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDisableContentLogging" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether to disable response content logging (unless {@link Level#ALL} is loggable which
 forces all logging).

 <p>
 Useful for example if content has sensitive data such as an authentication token. Defaults to
 {@code false}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="parse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="java.lang.String"/>
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[Parses the given URL-encoded content into the given data object of data key name/value pairs,
 including support for repeating data key names.

 <p>
 Declared fields of a "primitive" type (as defined by {@link Data#isPrimitive(Type)} are parsed
 using {@link Data#parsePrimitiveValue(Type, String)} where the {@link Class} parameter is the
 declared field class. Declared fields of type {@link Collection} are used to support repeating
 data key names, so each member of the collection is an additional data key value. They are
 parsed the same as "primitive" fields, except that the generic type parameter of the collection
 is used as the {@link Class} parameter.
 </p>

 <p>
 If there is no declared field for an input parameter name, it will be ignored unless the input
 {@code data} parameter is a {@link Map}. If it is a map, the parameter value will be stored
 either as a string, or as a {@link ArrayList}&lt;String&gt; in the case of repeated parameters.
 </p>

 @param content URL-encoded content or {@code null} to ignore content
 @param data data key name/value pairs]]>
      </doc>
    </method>
    <method name="builder" return="com.google.api.client.http.UrlEncodedParser.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an instance of a new builder.

 @since 1.5]]>
      </doc>
    </method>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/x-www-form-urlencoded"} content type.]]>
      </doc>
    </field>
    <field name="disableContentLogging" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getDisableContentLogging}
             or {@link Builder#setDisableContentLogging}">
      <doc>
      <![CDATA[Whether to disable response content logging (unless {@link Level#ALL} is loggable which forces
 all logging).
 <p>
 Useful for example if content has sensitive data such as an authentication token. Defaults to
 {@code false}.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getDisableContentLogging}
             or {@link Builder#setDisableContentLogging}]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getContentType} or
             {@link Builder#setContentType}">
      <doc>
      <![CDATA[Content type. Default value is {@link #CONTENT_TYPE}.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getContentType} or
             {@link Builder#setContentType}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Implements support for HTTP form content encoding parsing of type {@code
 application/x-www-form-urlencoded} as specified in the <a href=
 "http://www.w3.org/TR/1998/REC-html40-19980424/interact/forms.html#h-17.13.4.1" >HTML 4.0
 Specification</a>.

 <p>
 Implementation is thread-safe as long as the fields are not set directly (which is deprecated
 usage).
 </p>

 <p>
 The data is parsed using {@link #parse(String, Object)}.
 </p>

 <p>
 Sample usage:

 <pre>
 <code>
  static void setParser(HttpTransport transport) {
    transport.addParser(new UrlEncodedParser());
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.UrlEncodedParser -->
  <!-- start class com.google.api.client.http.UrlEncodedParser.Builder -->
  <class name="UrlEncodedParser.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UrlEncodedParser.Builder"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="build" return="com.google.api.client.http.UrlEncodedParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new instance of {@link UrlEncodedParser}.]]>
      </doc>
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type or {@code null} for none.]]>
      </doc>
    </method>
    <method name="setContentType" return="com.google.api.client.http.UrlEncodedParser.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content type.

 <p>
 Default value is {@link #CONTENT_TYPE}.
 </p>]]>
      </doc>
    </method>
    <method name="getDisableContentLogging" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether to disable response content logging (unless {@link Level#ALL} is loggable
 which forces all logging).

 <p>
 Useful for example if content has sensitive data such as an authentication token. Defaults to
 {@code false}.
 </p>]]>
      </doc>
    </method>
    <method name="setDisableContentLogging" return="com.google.api.client.http.UrlEncodedParser.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="disableContentLogging" type="boolean"/>
      <doc>
      <![CDATA[Sets whether to disable response content logging (unless {@link Level#ALL} is loggable which
 forces all logging).

 <p>
 Useful for example if content has sensitive data such as an authentication token. Defaults to
 {@code false}.
 </p>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder for {@link UrlEncodedParser}.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.UrlEncodedParser.Builder -->
</package>
<package name="com.google.api.client.http.apache">
  <!-- start class com.google.api.client.http.apache.ApacheHttpTransport -->
  <class name="ApacheHttpTransport" extends="com.google.api.client.http.HttpTransport"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ApacheHttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 1.3]]>
      </doc>
    </constructor>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="supportsPatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shuts down the connection manager and releases allocated resources. This includes closing all
 connections, whether they are currently used or not.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getHttpClient" return="HttpClient"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Apache HTTP client.

 @since 1.5]]>
      </doc>
    </method>
    <field name="httpClient" type="HttpClient"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getHttpClient}">
      <doc>
      <![CDATA[Apache HTTP client.

 @since 1.1
 @deprecated (scheduled to be made private in 1.6) Use {@link #getHttpClient}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Thread-safe HTTP transport based on the Apache HTTP Client library.

 <p>
 Implementation is thread-safe, as long as any parameter modification to the
 {@link #getHttpClient() Apache HTTP Client} is only done at initialization time. For maximum
 efficiency, applications should use a single globally-shared instance of the HTTP transport.
 </p>

 <p>
 Default settings:
 </p>

 <ul>
 <li>The client connection manager is set to {@link ThreadSafeClientConnManager}.</li>
 <li>Timeout is set to 20 seconds using {@link ConnManagerParams#setTimeout},
 {@link HttpConnectionParams#setConnectionTimeout}, and {@link HttpConnectionParams#setSoTimeout}.
 </li>
 <li>The socket buffer size is set to 8192 using {@link HttpConnectionParams#setSocketBufferSize}.
 </li>
 </ul>

 <p>
 These parameters may be overridden by setting the values on the {@link #httpClient}.
 {@link HttpClient#getParams() getParams()}. Please read the <a
 href="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html">Apache HTTP
 Client connection management tutorial</a> for more complex configuration questions, such as how
 to set up an HTTP proxy.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.apache.ApacheHttpTransport -->
</package>
<package name="com.google.api.client.http.javanet">
  <!-- start class com.google.api.client.http.javanet.NetHttpTransport -->
  <class name="NetHttpTransport" extends="com.google.api.client.http.HttpTransport"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NetHttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Thread-safe HTTP low-level transport based on the {@code java.net} package.

 <p>
 Implementation is thread-safe. For maximum efficiency, applications should use a single
 globally-shared instance of the HTTP transport.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.javanet.NetHttpTransport -->
</package>
<package name="com.google.api.client.http.json">
  <!-- start class com.google.api.client.http.json.JsonHttpContent -->
  <class name="JsonHttpContent" extends="com.google.api.client.http.AbstractHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonHttpContent"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #JsonHttpContent(JsonFactory, Object)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use {@link #JsonHttpContent(JsonFactory, Object)}]]>
      </doc>
    </constructor>
    <constructor name="JsonHttpContent" type="com.google.api.client.json.JsonFactory, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param jsonFactory JSON factory to use
 @param data JSON key name/value data
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setType" return="com.google.api.client.http.json.JsonHttpContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content type or {@code null} for none.

 <p>
 Defaults to {@link Json#CONTENT_TYPE}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getData" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON key name/value data.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getJsonFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON factory.

 @since 1.5]]>
      </doc>
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getType} or {@link #setType}">
      <doc>
      <![CDATA[Content type. Default value is {@link Json#CONTENT_TYPE}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getType} or {@link #setType}]]>
      </doc>
    </field>
    <field name="data" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getData}">
      <doc>
      <![CDATA[JSON key name/value data.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getData}]]>
      </doc>
    </field>
    <field name="jsonFactory" type="com.google.api.client.json.JsonFactory"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getJsonFactory}">
      <doc>
      <![CDATA[JSON factory.

 @since 1.3
 @deprecated (scheduled to be made private final in 1.6) Use {@link #getJsonFactory}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes JSON HTTP content based on the data key/value mapping object for an item.

 <p>
 Sample usage:
 </p>

 <pre>
 <code>
  static void setContent(HttpRequest request, Object data) {
    request.setContent(new JsonHttpContent(new JacksonFactory(), data));
  }
 </code>
 </pre>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.json.JsonHttpContent -->
  <!-- start class com.google.api.client.http.json.JsonHttpParser -->
  <class name="JsonHttpParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <constructor name="JsonHttpParser"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #JsonHttpParser(JsonFactory)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use {@link #JsonHttpParser(JsonFactory)}]]>
      </doc>
    </constructor>
    <constructor name="JsonHttpParser" type="com.google.api.client.json.JsonFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param jsonFactory JSON factory
 @since 1.5]]>
      </doc>
    </constructor>
    <constructor name="JsonHttpParser" type="com.google.api.client.json.JsonFactory, java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param jsonFactory JSON factory
 @param contentType content type or {@code null} for none
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON factory.

 @since 1.5]]>
      </doc>
    </method>
    <method name="parserForResponse" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jsonFactory" type="com.google.api.client.json.JsonFactory"/>
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a JSON parser to use for parsing the given HTTP response.
 <p>
 The response content will be closed if any throwable is thrown. On success, the current token
 will be the first top token, which is normally {@link JsonToken#START_ARRAY} or
 {@link JsonToken#START_OBJECT}.
 </p>

 @param jsonFactory JSON factory to use
 @param response HTTP response
 @return JSON parser
 @throws IllegalArgumentException if content type is not {@link Json#CONTENT_TYPE}
 @since 1.3]]>
      </doc>
    </method>
    <method name="builder" return="com.google.api.client.http.json.JsonHttpParser.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jsonFactory" type="com.google.api.client.json.JsonFactory"/>
      <doc>
      <![CDATA[Returns an instance of a new builder.

 @param jsonFactory JSON factory
 @since 1.5]]>
      </doc>
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getContentType} or
             {@link Builder#setContentType}">
      <doc>
      <![CDATA[Content type. Default value is {@link Json#CONTENT_TYPE}.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getContentType} or
             {@link Builder#setContentType}]]>
      </doc>
    </field>
    <field name="jsonFactory" type="com.google.api.client.json.JsonFactory"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getJsonFactory}">
      <doc>
      <![CDATA[JSON factory.

 @since 1.3
 @deprecated (scheduled to be made private final in 1.6) Use {@link #getJsonFactory}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Parses HTTP JSON response content into an data class of key/value pairs.

 <p>
 Implementation is thread-safe as long as the fields are not set directly (which is deprecated
 usage).
 </p>

 <p>
 Sample usage:
 </p>

 <pre>
 <code>
  static void setParser(HttpRequest request) {
    request.addParser(new JsonHttpParser(new JacksonFactory()));
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.json.JsonHttpParser -->
  <!-- start class com.google.api.client.http.json.JsonHttpParser.Builder -->
  <class name="JsonHttpParser.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonHttpParser.Builder" type="com.google.api.client.json.JsonFactory"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param jsonFactory JSON factory]]>
      </doc>
    </constructor>
    <method name="build" return="com.google.api.client.http.json.JsonHttpParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new instance of {@link JsonHttpParser}.]]>
      </doc>
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type or {@code null} for none.]]>
      </doc>
    </method>
    <method name="setContentType" return="com.google.api.client.http.json.JsonHttpParser.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content type.

 <p>
 Default value is {@link Json#CONTENT_TYPE}.
 </p>]]>
      </doc>
    </method>
    <method name="getJsonFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON factory.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder for {@link JsonHttpParser}.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.json.JsonHttpParser.Builder -->
</package>
<package name="com.google.api.client.http.protobuf">
  <!-- start class com.google.api.client.http.protobuf.ProtoHttpContent -->
  <class name="ProtoHttpContent" extends="com.google.api.client.http.AbstractHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProtoHttpContent" type="MessageLite"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param message message to serialize]]>
      </doc>
    </constructor>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setType" return="com.google.api.client.http.protobuf.ProtoHttpContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content type or {@code null} for none.

 <p>
 Default value is {@link ProtocolBuffers#CONTENT_TYPE}.
 </p>]]>
      </doc>
    </method>
    <method name="getMessage" return="MessageLite"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the message to serialize.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Serializes of a protocol buffer message to HTTP content.

 <p>
 Sample usage:
 </p>

 <pre>
 <code>
  static HttpRequest buildPostRequest(
      HttpRequestFactory requestFactory, GenericUrl url, MessageLite message) throws IOException {
    return requestFactory.buildPostRequest(url, new ProtoHttpContent(message));
  }
 </code>
 </pre>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.5
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.protobuf.ProtoHttpContent -->
  <!-- start class com.google.api.client.http.protobuf.ProtoHttpParser -->
  <class name="ProtoHttpParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <constructor name="ProtoHttpParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProtoHttpParser" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param contentType content type]]>
      </doc>
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="builder" return="com.google.api.client.http.protobuf.ProtoHttpParser.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an instance of a new builder.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Parses protocol buffer HTTP response content into a protocol buffer message.

 <p>
 Implementation is immutable and therefore thread-safe.
 </p>

 <p>
 Sample usage:
 </p>

 <pre>
 <code>
  static void setParser(HttpRequest request) {
    request.addParser(new ProtoHttpParser());
  }
 </code>
 </pre>

 @since 1.5
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.protobuf.ProtoHttpParser -->
  <!-- start class com.google.api.client.http.protobuf.ProtoHttpParser.Builder -->
  <class name="ProtoHttpParser.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProtoHttpParser.Builder"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="build" return="com.google.api.client.http.protobuf.ProtoHttpParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new instance of {@link ProtoHttpParser}.]]>
      </doc>
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type or {@code null} for none.]]>
      </doc>
    </method>
    <method name="setContentType" return="com.google.api.client.http.protobuf.ProtoHttpParser.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content type.

 <p>
 Default value is {@link ProtocolBuffers#CONTENT_TYPE}.
 </p>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder for {@link ProtoHttpParser}.
 <p>
 Implementation is not thread-safe.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.protobuf.ProtoHttpParser.Builder -->
</package>
<package name="com.google.api.client.http.xml">
  <!-- start class com.google.api.client.http.xml.AbstractXmlHttpContent -->
  <class name="AbstractXmlHttpContent" extends="com.google.api.client.http.AbstractHttpContent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractXmlHttpContent"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use
             {@link #AbstractXmlHttpContent(XmlNamespaceDictionary)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use
             {@link #AbstractXmlHttpContent(XmlNamespaceDictionary)}]]>
      </doc>
    </constructor>
    <constructor name="AbstractXmlHttpContent" type="com.google.api.client.xml.XmlNamespaceDictionary"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param namespaceDictionary XML namespace dictionary
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setType" return="com.google.api.client.http.xml.AbstractXmlHttpContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content type or {@code null} for none.

 <p>
 Defaults to {@link XmlHttpParser#CONTENT_TYPE}, though subclasses may define a different
 default value.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getNamespaceDictionary" return="com.google.api.client.xml.XmlNamespaceDictionary"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the XML namespace dictionary.

 @since 1.5]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the content to the given XML serializer.

 @throws IOException I/O exception]]>
      </doc>
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getType} or {@link #setType}">
      <doc>
      <![CDATA[Content type. Default value is {@link XmlHttpParser#CONTENT_TYPE}, though subclasses may define
 a different default value.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getType} or {@link #setType}]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getNamespaceDictionary}">
      <doc>
      <![CDATA[XML namespace dictionary.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getNamespaceDictionary}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Abstract serializer for XML HTTP content based on the data key/value mapping object for an item.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.AbstractXmlHttpContent -->
  <!-- start class com.google.api.client.http.xml.XmlHttpContent -->
  <class name="XmlHttpContent" extends="com.google.api.client.http.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="XmlHttpContent"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use
             {@link #XmlHttpContent(XmlNamespaceDictionary, String, Object)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use
             {@link #XmlHttpContent(XmlNamespaceDictionary, String, Object)}]]>
      </doc>
    </constructor>
    <constructor name="XmlHttpContent" type="com.google.api.client.xml.XmlNamespaceDictionary, java.lang.String, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[XML namespace dictionary.

 @param namespaceDictionary XML namespace dictionary
 @param elementName XML element local name, optionally prefixed by its namespace alias, for
        example {@code "atom:entry"}
 @param data Key/value pair data
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="setType" return="com.google.api.client.http.xml.XmlHttpContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getElementName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the XML element local name, optionally prefixed by its namespace alias, for example
 {@code "atom:entry"}.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getData" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key/value pair data.

 @since 1.5]]>
      </doc>
    </method>
    <field name="elementName" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getElementName}">
      <doc>
      <![CDATA[XML element local name, optionally prefixed by its namespace alias, for example {@code
 "atom:entry"}.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getElementName}]]>
      </doc>
    </field>
    <field name="data" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getData}">
      <doc>
      <![CDATA[Key/value pair data.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getData}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes XML HTTP content based on the data key/value mapping object for an item.

 <p>
 Sample usage:
 </p>

 <pre>
 <code>
  static void setContent(HttpRequest request, XmlNamespaceDictionary namespaceDictionary,
      String elementName, Object data) {
    request.setContent(new XmlHttpContent(namespaceDictionary, elementName, data));
  }
 </code>
 </pre>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.XmlHttpContent -->
  <!-- start class com.google.api.client.http.xml.XmlHttpParser -->
  <class name="XmlHttpParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <constructor name="XmlHttpParser"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #XmlHttpParser(XmlNamespaceDictionary)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use {@link #XmlHttpParser(XmlNamespaceDictionary)}]]>
      </doc>
    </constructor>
    <constructor name="XmlHttpParser" type="com.google.api.client.xml.XmlNamespaceDictionary"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param namespaceDictionary XML namespace dictionary
 @since 1.5]]>
      </doc>
    </constructor>
    <constructor name="XmlHttpParser" type="com.google.api.client.xml.XmlNamespaceDictionary, java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param namespaceDictionary XML namespace dictionary
 @param contentType content type or {@code null} for none
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Default implementation parses the content of the response into the data class of key/value
 pairs, but subclasses may override.]]>
      </doc>
    </method>
    <method name="getNamespaceDictionary" return="com.google.api.client.xml.XmlNamespaceDictionary"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the XML namespace dictionary.

 @since 1.5]]>
      </doc>
    </method>
    <method name="builder" return="com.google.api.client.http.xml.XmlHttpParser.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <doc>
      <![CDATA[Returns an instance of a new builder.

 @param namespaceDictionary XML namespace dictionary
 @since 1.5]]>
      </doc>
    </method>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/xml"} content type.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getContentType} or
             {@link Builder#setContentType}">
      <doc>
      <![CDATA[Content type. Default value is {@link #CONTENT_TYPE}.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getContentType} or
             {@link Builder#setContentType}]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getNamespaceDictionary}">
      <doc>
      <![CDATA[XML namespace dictionary.

 @since 1.3
 @deprecated (scheduled to be made private final in 1.6) Use {@link #getNamespaceDictionary}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[XML HTTP parser into an data class of key/value pairs.

 <p>
 Implementation is thread-safe as long as the fields are not set directly (which is deprecated
 usage).
 </p>

 <p>
 Sample usage:
 </p>

 <pre>
 <code>
  static void setParser(HttpRequest request, XmlNamespaceDictionary namespaceDictionary) {
    request.addParser(new XmlHttpParser(namespaceDictionary));
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.XmlHttpParser -->
  <!-- start class com.google.api.client.http.xml.XmlHttpParser.Builder -->
  <class name="XmlHttpParser.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="XmlHttpParser.Builder" type="com.google.api.client.xml.XmlNamespaceDictionary"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param namespaceDictionary XML namespace dictionary]]>
      </doc>
    </constructor>
    <method name="build" return="com.google.api.client.http.xml.XmlHttpParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new instance of {@link XmlHttpParser}.]]>
      </doc>
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type or {@code null} for none.]]>
      </doc>
    </method>
    <method name="setContentType" return="com.google.api.client.http.xml.XmlHttpParser.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content type.

 <p>
 Default value is {@link #CONTENT_TYPE}.
 </p>]]>
      </doc>
    </method>
    <method name="getNamespaceDictionary" return="com.google.api.client.xml.XmlNamespaceDictionary"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the XML namespace dictionary.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder for {@link XmlHttpParser}.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.XmlHttpParser.Builder -->
</package>
<package name="com.google.api.client.http.xml.atom">
  <!-- start class com.google.api.client.http.xml.atom.AtomContent -->
  <class name="AtomContent" extends="com.google.api.client.http.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomContent"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use
             {@link #forEntry(XmlNamespaceDictionary, Object)} or
             {@link #AtomContent(XmlNamespaceDictionary, Object, boolean)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use
             {@link #forEntry(XmlNamespaceDictionary, Object)} or
             {@link #AtomContent(XmlNamespaceDictionary, Object, boolean)}]]>
      </doc>
    </constructor>
    <constructor name="AtomContent" type="com.google.api.client.xml.XmlNamespaceDictionary, java.lang.Object, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param namespaceDictionary XML namespace dictionary
 @param entry key/value pair data for the Atom entry
 @param isEntry {@code true} for an Atom entry or {@code false} for an Atom feed
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="forEntry" return="com.google.api.client.http.xml.atom.AtomContent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <param name="entry" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a new instance of HTTP content for an Atom entry.

 @param namespaceDictionary XML namespace dictionary
 @param entry data key/value pair for the Atom entry
 @since 1.5]]>
      </doc>
    </method>
    <method name="forFeed" return="com.google.api.client.http.xml.atom.AtomContent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <param name="feed" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a new instance of HTTP content for an Atom feed.

 @param namespaceDictionary XML namespace dictionary
 @param feed data key/value pair for the Atom feed
 @since 1.5]]>
      </doc>
    </method>
    <method name="setType" return="com.google.api.client.http.xml.atom.AtomContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} for an Atom entry or {@code false} for an Atom feed.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getData" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key name/value pair data for the Atom entry or Atom feed.

 @since 1.5]]>
      </doc>
    </method>
    <field name="entry" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getData}">
      <doc>
      <![CDATA[Key/value pair data for the Atom entry.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getData}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes Atom XML HTTP content based on the data key/value mapping object for an Atom entry.

 <p>
 Default value for {@link #getType()} is {@link Atom#CONTENT_TYPE}.
 </p>

 <p>
 Sample usages:
 </p>

 <pre>
 <code>
  static void setAtomEntryContent(
      HttpRequest request, XmlNamespaceDictionary namespaceDictionary, Object entry) {
    request.setContent(AtomContent.forEntry(namespaceDictionary, entry));
  }

  static void setAtomBatchContent(
      HttpRequest request, XmlNamespaceDictionary namespaceDictionary, Object batchFeed) {
    request.setContent(AtomContent.forFeed(namespaceDictionary, batchFeed));
  }
 </code>
 </pre>

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.atom.AtomContent -->
  <!-- start class com.google.api.client.http.xml.atom.AtomFeedContent -->
  <class name="AtomFeedContent" extends="com.google.api.client.http.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.6) Use {@link AtomContent#forFeed}">
    <constructor name="AtomFeedContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="feed" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data for the Atom feed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes Atom XML HTTP content based on the data key/value mapping object for an Atom feed.
 <p>
 Default value for {@link #contentType} is {@link Atom#CONTENT_TYPE}.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setContent(
      HttpRequest request, XmlNamespaceDictionary namespaceDictionary, Object feed) {
    AtomFeedContent content = new AtomFeedContent();
    content.namespaceDictionary = namespaceDictionary;
    content.feed = feed;
    request.content = content;
  }
 </code>
 </pre>

 @since 1.4
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.6) Use {@link AtomContent#forFeed}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.atom.AtomFeedContent -->
  <!-- start class com.google.api.client.http.xml.atom.AtomFeedParser -->
  <class name="AtomFeedParser" extends="com.google.api.client.xml.atom.AbstractAtomFeedParser&lt;T&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomFeedParser"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #AtomFeedParser(XmlNamespaceDictionary,
             XmlPullParser, InputStream, Class, Class)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use {@link #AtomFeedParser(XmlNamespaceDictionary,
             XmlPullParser, InputStream, Class, Class)}]]>
      </doc>
    </constructor>
    <constructor name="AtomFeedParser" type="com.google.api.client.xml.XmlNamespaceDictionary, XmlPullParser, java.io.InputStream, java.lang.Class&lt;T&gt;, java.lang.Class&lt;E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param namespaceDictionary XML namespace dictionary
 @param parser XML pull parser to use
 @param inputStream input stream to read
 @param feedClass feed class to parse
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="parseNextEntry" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <method name="parseEntryInternal" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <method name="getEntryClass" return="java.lang.Class&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Atom entry class to parse.

 @since 1.5]]>
      </doc>
    </method>
    <method name="create" return="com.google.api.client.http.xml.atom.AtomFeedParser&lt;T, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <param name="feedClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="entryClass" type="java.lang.Class&lt;E&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parses the given HTTP response using the given feed class and entry class.

 @param <T> feed type
 @param <E> entry type
 @param response HTTP response
 @param namespaceDictionary XML namespace dictionary
 @param feedClass feed class
 @param entryClass entry class
 @return Atom feed parser
 @throws IOException I/O exception
 @throws XmlPullParserException XML pull parser exception]]>
      </doc>
    </method>
    <field name="entryClass" type="java.lang.Class&lt;E&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getEntryClass}">
      <doc>
      <![CDATA[Atom entry class to parse.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getEntryClass}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Atom feed pull parser when the Atom entry class is known in advance.

 <p>
 Implementation is not thread-safe.
 </p>

 @param <T> feed type
 @param <E> entry type
 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.atom.AtomFeedParser -->
  <!-- start class com.google.api.client.http.xml.atom.AtomParser -->
  <class name="AtomParser" extends="com.google.api.client.http.xml.XmlHttpParser"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomParser"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #AtomParser(XmlNamespaceDictionary)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use {@link #AtomParser(XmlNamespaceDictionary)}]]>
      </doc>
    </constructor>
    <constructor name="AtomParser" type="com.google.api.client.xml.XmlNamespaceDictionary"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param namespaceDictionary XML namespace dictionary
 @since 1.5]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Atom XML HTTP parser into an data class of key/value pairs.

 <p>
 It overrides the {@link #getContentType} to {@link Atom#CONTENT_TYPE}.
 </p>

 <p>
 Implementation is thread-safe as long as the fields are not set directly (which is deprecated
 usage).
 </p>

 <p>
 Sample usage:
 </p>

 <pre>
 <code>
  static void setParser(HttpRequest request, XmlNamespaceDictionary namespaceDictionary) {
    request.addParser(new AtomParser(namespaceDictionary));
  }
 </code>
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.atom.AtomParser -->
</package>
<package name="com.google.api.client.json">
  <!-- start class com.google.api.client.json.CustomizeJsonParser -->
  <class name="CustomizeJsonParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CustomizeJsonParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stopAt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether to stop parsing at the given key of the given context object.]]>
      </doc>
    </method>
    <method name="handleUnrecognizedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Called when the given unrecognized key is encountered in the given context object.]]>
      </doc>
    </method>
    <method name="newInstanceForArray" return="java.util.Collection&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns a new instance value for the given field in the given context object for a JSON array
 or {@code null} for the default behavior.]]>
      </doc>
    </method>
    <method name="newInstanceForObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="fieldClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new instance value for the given field class in the given context object for JSON
 Object or {@code null} for the default behavior.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Customizes the behavior of a JSON parser.

 <p>
 All methods have a default trivial implementation, so subclasses need only implement the methods
 whose behavior needs customization.
 </p>

 <p>
 Implementation has no fields and therefore thread-safe, but sub-classes are not necessarily
 thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.CustomizeJsonParser -->
  <!-- start class com.google.api.client.json.GenericJson -->
  <class name="GenericJson" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="GenericJson"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.json.GenericJson"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="jsonFactory" type="com.google.api.client.json.JsonFactory"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[JSON factory to use for {@link #toString()}.

 @since 1.3]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic JSON data that stores all unknown key name/value pairs.

 <p>
 Subclasses can declare fields for known data keys using the {@link Key} annotation. Each field
 can be of any visibility (private, package private, protected, or public) and must not be static.
 {@code null} unknown data key names are not allowed, but {@code null} data values are allowed.

 <p>
 Implementation is not thread-safe. For a thread-safe choice instead use an implementation of
 {@link ConcurrentMap}.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.GenericJson -->
  <!-- start class com.google.api.client.json.Json -->
  <class name="Json" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Json"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/json"} content type.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[JSON utilities.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.Json -->
  <!-- start class com.google.api.client.json.JsonEncoding -->
  <class name="JsonEncoding" extends="java.lang.Enum&lt;com.google.api.client.json.JsonEncoding&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.json.JsonEncoding[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.json.JsonEncoding"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Enumeration that defines legal encodings that can be used for JSON content, based on list of
 allowed encodings from <a href="http://www.ietf.org/rfc/rfc4627.txt">JSON specification</a>.

 <p>
 Limitation: currently only UTF-8 encoding is supported.
 </p>
 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonEncoding -->
  <!-- start class com.google.api.client.json.JsonFactory -->
  <class name="JsonFactory" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a new instance of a low-level JSON parser for the given input stream.

 @param in input stream
 @return new instance of a low-level JSON parser
 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a new instance of a low-level JSON parser for the given string value.

 @param value string value
 @return new instance of a low-level JSON parser
 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a new instance of a low-level JSON parser for the given reader.

 @param reader reader
 @return new instance of a low-level JSON parser
 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="enc" type="com.google.api.client.json.JsonEncoding"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a new instance of a low-level JSON serializer for the given output stream and encoding.

 @param out output stream
 @param enc encoding
 @return new instance of a low-level JSON serializer
 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a new instance of a low-level JSON serializer for the given writer.

 @param writer writer
 @return new instance of a low-level JSON serializer
 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a serialized JSON string representation for the given item using
 {@link JsonGenerator#serialize(Object)}.

 @param item data key/value pairs
 @return serialized JSON string representation]]>
      </doc>
    </method>
    <method name="fromString" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <param name="destinationClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses a string value as a JSON object, array, or value into a new instance of the given
 destination class using {@link JsonParser#parse(Class, CustomizeJsonParser)}.

 @param value JSON string value
 @param destinationClass destination class that has an accessible default constructor to use to
        create a new instance
 @return new instance of the parsed destination class
 @since 1.4]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract low-level JSON factory.

 <p>
 Implementation is thread-safe, and sub-classes must be thread-safe. For maximum efficiency,
 applications should use a single globally-shared instance of the JSON factory.
 </p>

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonFactory -->
  <!-- start class com.google.api.client.json.JsonGenerator -->
  <class name="JsonGenerator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonGenerator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFactory" return="com.google.api.client.json.JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON factory from which this generator was created.]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flushes any buffered content to the underlying output stream or writer.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes the serializer and the underlying output stream or writer, and releases any memory
 associated with it.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeStartArray"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON start array character '['.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeEndArray"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON end array character ']'.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeStartObject"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON start object character '{'.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeEndObject"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON end object character '}'.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeFieldName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON quoted field name.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNull"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a literal JSON null value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeString"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON quoted string value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeBoolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a literal JSON boolean value ('true' or 'false').

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON int value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON long value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.math.BigInteger"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON big integer value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON float value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON double value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.math.BigDecimal"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON big decimal value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedValue" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON numeric value that has already been encoded properly.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes the given JSON value object.

 @param value JSON value object or {@code null} to ignore]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract low-level JSON serializer.

 <p>
 Implementation has no fields and therefore thread-safe, but sub-classes are not necessarily
 thread-safe.
 </p>

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonGenerator -->
  <!-- start class com.google.api.client.json.JsonParser -->
  <class name="JsonParser" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFactory" return="com.google.api.client.json.JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON factory from which this generator was created.]]>
      </doc>
    </method>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes the parser and the underlying input stream or reader, and releases any memory associated
 with it.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="nextToken" return="com.google.api.client.json.JsonToken"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the next token from the stream or {@code null} to indicate end of input.]]>
      </doc>
    </method>
    <method name="getCurrentToken" return="com.google.api.client.json.JsonToken"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the token the parser currently points to or {@code null} for none (at start of input or
 after end of input).]]>
      </doc>
    </method>
    <method name="getCurrentName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the most recent field name or {@code null} for array values or for root-level values.]]>
      </doc>
    </method>
    <method name="skipChildren" return="com.google.api.client.json.JsonParser"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips to the matching {@link JsonToken#END_ARRAY} if current token is
 {@link JsonToken#START_ARRAY}, the matching {@link JsonToken#END_OBJECT} if the current token
 is {@link JsonToken#START_OBJECT}, else does nothing.]]>
      </doc>
    </method>
    <method name="getText" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a textual representation of the current token or {@code null} if
 {@link #getCurrentToken()} is {@code null}.]]>
      </doc>
    </method>
    <method name="getByteValue" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the byte value of the current token.]]>
      </doc>
    </method>
    <method name="getShortValue" return="short"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the short value of the current token.]]>
      </doc>
    </method>
    <method name="getIntValue" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the int value of the current token.]]>
      </doc>
    </method>
    <method name="getFloatValue" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the float value of the current token.]]>
      </doc>
    </method>
    <method name="getLongValue" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the long value of the current token.]]>
      </doc>
    </method>
    <method name="getDoubleValue" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the double value of the current token.]]>
      </doc>
    </method>
    <method name="getBigIntegerValue" return="java.math.BigInteger"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the {@link BigInteger} value of the current token.]]>
      </doc>
    </method>
    <method name="getDecimalValue" return="java.math.BigDecimal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the {@link BigDecimal} value of the current token.]]>
      </doc>
    </method>
    <method name="parseAndClose" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON object, array, or value into a new instance of the given destination class using
 {@link JsonParser#parse(Class, CustomizeJsonParser)}, and then closes the parser.

 @param <T> destination class type
 @param destinationClass destination class that has a public default constructor to use to
        create a new instance
 @param customizeParser optional parser customizer or {@code null} for none
 @return new instance of the parsed destination class]]>
      </doc>
    </method>
    <method name="skipToKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="keyToFind" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips the values of all keys in the current object until it finds the given key.
 <p>
 Before this method is called, the parser must either point to the start or end of a JSON object
 or to a field name. After this method ends, the current token will either be the
 {@link JsonToken#END_OBJECT} of the current object if the key is not found, or the value of the
 key that was found.
 </p>

 @param keyToFind key to find]]>
      </doc>
    </method>
    <method name="parseAndClose"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destination" type="java.lang.Object"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Object from the given JSON parser -- which is closed after parsing completes --
 into the given destination object, optionally using the given parser customizer.
 <p>
 Before this method is called, the parser must either point to the start or end of a JSON object
 or to a field name.
 </p>

 @param destination destination object
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON object, array, or value into a new instance of the given destination class,
 optionally using the given parser customizer.
 <p>
 If it parses an object, after this method ends, the current token will be the object's ending
 {@link JsonToken#END_OBJECT}. If it parses an array, after this method ends, the current token
 will be the array's ending {@link JsonToken#END_ARRAY}.
 </p>

 @param <T> destination class type
 @param destinationClass destination class that has a public default constructor to use to
        create a new instance
 @param customizeParser optional parser customizer or {@code null} for none
 @return new instance of the parsed destination class]]>
      </doc>
    </method>
    <method name="parse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destination" type="java.lang.Object"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON object from the given JSON parser into the given destination object, optionally
 using the given parser customizer.
 <p>
 Before this method is called, the parser must either point to the start or end of a JSON object
 or to a field name. After this method ends, the current token will be the
 {@link JsonToken#END_OBJECT} of the current object.
 </p>

 @param destination destination object
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <method name="parseArrayAndClose" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationCollectionClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser (which is closed after parsing completes) into
 the given destination collection, optionally using the given parser customizer.

 @param destinationCollectionClass class of destination collection (must have a public default
        constructor)
 @param destinationItemClass class of destination collection item (must have a public default
        constructor)
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <method name="parseArrayAndClose"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationCollection" type="java.util.Collection&lt;? super T&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser (which is closed after parsing completes) into
 the given destination collection, optionally using the given parser customizer.

 @param destinationCollection destination collection
 @param destinationItemClass class of destination collection item (must have a public default
        constructor)
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <method name="parseArray" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationCollectionClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser into the given destination collection, optionally
 using the given parser customizer.

 @param destinationCollectionClass class of destination collection (must have a public default
        constructor)
 @param destinationItemClass class of destination collection item (must have a public default
        constructor)
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <method name="parseArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationCollection" type="java.util.Collection&lt;? super T&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser into the given destination collection, optionally
 using the given parser customizer.

 @param destinationCollection destination collection
 @param destinationItemClass class of destination collection item (must have a public default
        constructor)
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract low-level JSON parser.

 <p>
 Implementation has no fields and therefore thread-safe, but sub-classes are not necessarily
 thread-safe.
 </p>

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonParser -->
  <!-- start class com.google.api.client.json.JsonString -->
  <class name="JsonString"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Use this annotation to specify that a declared numeric Java field should map to a JSON string.

 <p>
 By default declared Java numeric fields are stored as JSON numbers. For example:

 <pre>
 <code>
class A {
  &#64;Key BigInteger value;
}
 </code>
 </pre>

  can be used for this JSON content:

 <pre>
 <code>
{"value" : 12345768901234576890123457689012345768901234576890}
 </code>
 </pre>

  However, if instead the JSON content uses a JSON String to store the value, one needs to use the
 {@link JsonString} annotation. For example:

 <pre>
 <code>
class B {
  &#64;Key &#64;JsonString BigInteger value;
}
 </code>
 </pre>

  can be used for this JSON content:

 <pre>
 <code>
{"value" : "12345768901234576890123457689012345768901234576890"}
 </code>
 </pre>
 </p>

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonString -->
  <!-- start class com.google.api.client.json.JsonToken -->
  <class name="JsonToken" extends="java.lang.Enum&lt;com.google.api.client.json.JsonToken&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.json.JsonToken[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.json.JsonToken"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[JSON token in the low-level JSON library.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonToken -->
</package>
<package name="com.google.api.client.json.gson">
  <!-- start class com.google.api.client.json.gson.GsonFactory -->
  <class name="GsonFactory" extends="com.google.api.client.json.JsonFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GsonFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="enc" type="com.google.api.client.json.JsonEncoding"/>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON library implementation based on GSON.

 <p>
 Implementation is thread-safe, and sub-classes must be thread-safe. For maximum efficiency,
 applications should use a single globally-shared instance of the JSON factory.
 </p>

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.gson.GsonFactory -->
  <!-- start class com.google.api.client.json.gson.GsonGenerator -->
  <class name="GsonGenerator" extends="com.google.api.client.json.JsonGenerator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be made package-private in 1.6)">
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeEndArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeEndObject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFieldName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNull"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.math.BigInteger"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.math.BigDecimal"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedValue" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStartArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStartObject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON serializer implementation based on GSON.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.3
 @author Yaniv Inbar
 @deprecated (scheduled to be made package-private in 1.6)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.gson.GsonGenerator -->
  <!-- start class com.google.api.client.json.gson.GsonParser -->
  <class name="GsonParser" extends="com.google.api.client.json.JsonParser"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be made package-private in 1.6)">
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCurrentName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCurrentToken" return="com.google.api.client.json.JsonToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getByteValue" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getShortValue" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIntValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFloatValue" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBigIntegerValue" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDecimalValue" return="java.math.BigDecimal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDoubleValue" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLongValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextToken" return="com.google.api.client.json.JsonToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipChildren" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON serializer implementation based on GSON.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.3
 @author Yaniv Inbar
 @deprecated (scheduled to be made package-private in 1.6)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.gson.GsonParser -->
</package>
<package name="com.google.api.client.json.jackson">
  <!-- start class com.google.api.client.json.jackson.JacksonFactory -->
  <class name="JacksonFactory" extends="com.google.api.client.json.JsonFactory"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JacksonFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="enc" type="com.google.api.client.json.JsonEncoding"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON library implementation based on Jackson.

 <p>
 Implementation is thread-safe, and sub-classes must be thread-safe. For maximum efficiency,
 applications should use a single globally-shared instance of the JSON factory.
 </p>

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.jackson.JacksonFactory -->
</package>
<package name="com.google.api.client.json.rpc2">
  <!-- start class com.google.api.client.json.rpc2.JsonRpcRequest -->
  <class name="JsonRpcRequest" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonRpcRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the version of the JSON-RPC protocol which is {@code "2.0"}.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getId" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the identifier established by the client that must be a string or a number or {@code
 null} for a notification and therefore not expect to receive a response.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the identifier established by the client that must be a string or a number or {@code null}
 for a notification and therefore not expect to receive a response.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the method to be invoked.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the name of the method to be invoked.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getParameters" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the structured value that holds the parameter values to be used during the invocation
 of the method or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the structured value that holds the parameter values to be used during the invocation of
 the method or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <field name="jsonrpc" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getVersion()}">
      <doc>
      <![CDATA[Version of the JSON-RPC protocol which is {@code "2.0"}.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getVersion()}]]>
      </doc>
    </field>
    <field name="id" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getId()} or
             {@link #setId(Object)}">
      <doc>
      <![CDATA[Identifier established by the client that must be a string or a number or {@code null} for a
 notification and therefore not expect to receive a response.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getId()} or
             {@link #setId(Object)}]]>
      </doc>
    </field>
    <field name="method" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getMethod()} or
             {@link #setMethod(String)}">
      <doc>
      <![CDATA[Name of the method to be invoked.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getMethod()} or
             {@link #setMethod(String)}]]>
      </doc>
    </field>
    <field name="params" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getParameters()} or
             {@link #setParameters(Object)}">
      <doc>
      <![CDATA[Structured value that holds the parameter values to be used during the invocation of the method
 or {@code null} for none.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getParameters()} or
             {@link #setParameters(Object)}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[JSON-RPC 2.0 request object.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.rpc2.JsonRpcRequest -->
</package>
<package name="com.google.api.client.protobuf">
  <!-- start class com.google.api.client.protobuf.ProtocolBuffers -->
  <class name="ProtocolBuffers" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="parseAndClose" return="T extends MessageLite"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputStream" type="java.io.InputStream"/>
      <param name="messageClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses protocol buffer content from an input stream (closing the input stream) into a protocol
 buffer message.

 @param <T> destination message type
 @param messageClass destination message class that has a {@code parseFrom(InputStream)} public
        static method
 @return new instance of the parsed destination message class]]>
      </doc>
    </method>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/x-protobuf"} content type.]]>
      </doc>
    </field>
    <field name="ALT_CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/x-protobuffer"} content type.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Utilities for protocol buffers.

 <p>
 There is no official media type for protocol buffers registered with the <a
 href="http://www.iana.org/assignments/media-types/application/index.html">IANA</a>.
 {@link #CONTENT_TYPE} and {@link #ALT_CONTENT_TYPE} are some of the more popular choices being
 used today, but other media types are also in use.
 </p>

 @since 1.5
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.protobuf.ProtocolBuffers -->
</package>
<package name="com.google.api.client.testing.http">
  <!-- start class com.google.api.client.testing.http.MockHttpContent -->
  <class name="MockHttpContent" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="MockHttpContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContent" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP content.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContent" return="com.google.api.client.testing.http.MockHttpContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="byte[]"/>
      <doc>
      <![CDATA[Sets the HTTP content.

 <p>
 Default value is an empty byte array.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="setEncoding" return="com.google.api.client.testing.http.MockHttpContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encoding" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the HTTP content encoding or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setLength" return="com.google.api.client.testing.http.MockHttpContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Returns the HTTP content length or {@code -1} for unknown.

 <p>
 Default value is {@code -1}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="setType" return="com.google.api.client.testing.http.MockHttpContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the HTTP content type or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <field name="encoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getEncoding} or
             {@link #setEncoding}">
      <doc>
      <![CDATA[HTTP content encoding or {@code null} by default.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getEncoding} or
             {@link #setEncoding}]]>
      </doc>
    </field>
    <field name="length" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getLength} or {@link #setLength}">
      <doc>
      <![CDATA[HTTP content length or {@code -1} by default.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getLength} or {@link #setLength}]]>
      </doc>
    </field>
    <field name="type" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getType} or {@link #setType}">
      <doc>
      <![CDATA[HTTP content type or {@code null} by default.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getType} or {@link #setType}]]>
      </doc>
    </field>
    <field name="content" type="byte[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContent} or
             {@link #setContent}">
      <doc>
      <![CDATA[HTTP content or an empty byte array by default.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContent} or
             {@link #setContent}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Mock for {@link HttpContent}.

 <p>
 Implementation is not thread-safe.
 </p>

 @author Yaniv Inbar
 @since 1.3]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.http.MockHttpContent -->
  <!-- start class com.google.api.client.testing.http.MockHttpTransport -->
  <class name="MockHttpTransport" extends="com.google.api.client.http.HttpTransport"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MockHttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MockHttpTransport" type="java.util.Set&lt;com.google.api.client.http.HttpMethod&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param supportedOptionalMethods set of supported optional methods
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="getSupportedOptionalMethods" return="java.util.Set&lt;com.google.api.client.http.HttpMethod&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of supported optional methods.

 <p>
 Default value is {@link #DEFAULT_SUPPORTED_OPTIONAL_METHODS}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="setSupportedOptionalMethods"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supportedOptionalMethods" type="java.util.EnumSet&lt;com.google.api.client.http.HttpMethod&gt;"/>
      <doc>
      <![CDATA[@param supportedOptionalMethods the supportedOptionalMethods to set]]>
      </doc>
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="supportsPatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="builder" return="com.google.api.client.testing.http.MockHttpTransport.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an instance of a new builder.

 @since 1.5]]>
      </doc>
    </method>
    <field name="DEFAULT_SUPPORTED_OPTIONAL_METHODS" type="java.util.Set&lt;com.google.api.client.http.HttpMethod&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default supported optional methods.

 @since 1.5]]>
      </doc>
    </field>
    <field name="supportedOptionalMethods" type="java.util.EnumSet&lt;com.google.api.client.http.HttpMethod&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getSupportedOptionalMethods} or
             {@link Builder#setSupportedOptionalMethods}">
      <doc>
      <![CDATA[Set of supported optional methods or {@link HttpMethod#HEAD} and {@link HttpMethod#PATCH} by
 default.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getSupportedOptionalMethods} or
             {@link Builder#setSupportedOptionalMethods}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Mock for {@link HttpTransport}.

 <p>
 Implementation is thread-safe, as long as {@link #supportedOptionalMethods} is not modified
 directly (which is deprecated usage). For maximum efficiency, applications should use a single
 globally-shared instance of the HTTP transport.
 </p>

 @author Yaniv Inbar
 @since 1.3]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.http.MockHttpTransport -->
  <!-- start class com.google.api.client.testing.http.MockHttpTransport.Builder -->
  <class name="MockHttpTransport.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MockHttpTransport.Builder"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="build" return="com.google.api.client.testing.http.MockHttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new instance of {@link MockHttpTransport}.]]>
      </doc>
    </method>
    <method name="getSupportedOptionalMethods" return="java.util.Set&lt;com.google.api.client.http.HttpMethod&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of supported optional methods.

 <p>
 Default value is {@link #DEFAULT_SUPPORTED_OPTIONAL_METHODS}.
 </p>]]>
      </doc>
    </method>
    <method name="setSupportedOptionalMethods" return="com.google.api.client.testing.http.MockHttpTransport.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supportedOptionalMethods" type="java.util.Set&lt;com.google.api.client.http.HttpMethod&gt;"/>
      <doc>
      <![CDATA[Sets the set of supported optional methods.

 <p>
 Default value is {@link #DEFAULT_SUPPORTED_OPTIONAL_METHODS}.
 </p>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder for {@link MockHttpTransport}.

 <p>
 Implementation is not thread-safe.
 </p>

 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.http.MockHttpTransport.Builder -->
  <!-- start class com.google.api.client.testing.http.MockLowLevelHttpRequest -->
  <class name="MockLowLevelHttpRequest" extends="com.google.api.client.http.LowLevelHttpRequest"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MockLowLevelHttpRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MockLowLevelHttpRequest" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param url Request URL or {@code null} for none
 @since 1.4]]>
      </doc>
    </constructor>
    <method name="addHeader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="execute" return="com.google.api.client.http.LowLevelHttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the request URL or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getHeaders" return="java.util.Map&lt;java.lang.String, java.util.List&lt;java.lang.String&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the map of header name to values.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setUrl" return="com.google.api.client.testing.http.MockLowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the request URL or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getContent" return="com.google.api.client.http.HttpContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP content or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <field name="url" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getUrl} or {@link #setUrl}">
      <doc>
      <![CDATA[Request URL or {@code null} for none.

 @since 1.4
 @deprecated (scheduled to be made private in 1.6) Use {@link #getUrl} or {@link #setUrl}]]>
      </doc>
    </field>
    <field name="headers" type="&lt;any&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link #getHeaders} or {@link #getHeaders}">
      <doc>
      <![CDATA[Headers added in {@link #addHeader(String, String)}.

 @since 1.4
 @deprecated (scheduled to be removed in 1.6) Use {@link #getHeaders} or {@link #getHeaders}]]>
      </doc>
    </field>
    <field name="content" type="com.google.api.client.http.HttpContent"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContent} or
             {@link #setContent}">
      <doc>
      <![CDATA[HTTP content or {@code null} for none.

 @since 1.4
 @deprecated (scheduled to be made private in 1.6) Use {@link #getContent} or
             {@link #setContent}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Mock for {@link LowLevelHttpRequest}.

 <p>
 Implementation is not thread-safe.
 </p>

 @author Yaniv Inbar
 @since 1.3]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.http.MockLowLevelHttpRequest -->
  <!-- start class com.google.api.client.testing.http.MockLowLevelHttpResponse -->
  <class name="MockLowLevelHttpResponse" extends="com.google.api.client.http.LowLevelHttpResponse"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MockLowLevelHttpResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addHeader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a header to the response.

 @param name header name
 @param value header value]]>
      </doc>
    </method>
    <method name="setContent" return="com.google.api.client.testing.http.MockLowLevelHttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringContent" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the response content to the given content string.

 @param stringContent content string]]>
      </doc>
    </method>
    <method name="getContent" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getContentEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContentLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeaderCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeaderName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="getHeaderValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="getReasonPhrase" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStatusCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStatusLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeaderNames" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the list of header names of HTTP response.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setHeaderNames" return="com.google.api.client.testing.http.MockLowLevelHttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headerNames" type="java.util.ArrayList&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Sets the list of header names of HTTP response.

 <p>
 Default value is an empty list.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="getHeaderValues" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the list of header values of HTTP response.

 <p>
 Default value is an empty list.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="setHeaderValues" return="com.google.api.client.testing.http.MockLowLevelHttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headerValues" type="java.util.ArrayList&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Sets the list of header values of HTTP response.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContent" return="com.google.api.client.testing.http.MockLowLevelHttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Sets the input stream content of HTTP response or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContentType" return="com.google.api.client.testing.http.MockLowLevelHttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content type of HTTP response or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContentEncoding" return="com.google.api.client.testing.http.MockLowLevelHttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentEncoding" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the content encoding or {@code null} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setContentLength" return="com.google.api.client.testing.http.MockLowLevelHttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentLength" type="long"/>
      <doc>
      <![CDATA[Sets the content length or {@code 0} for none.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setStatusCode" return="com.google.api.client.testing.http.MockLowLevelHttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statusCode" type="int"/>
      <doc>
      <![CDATA[Sets the status code of HTTP response.

 <p>
 Default value is {@code 200}.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <field name="content" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContent} or
             {@link #setContent}">
      <doc>
      <![CDATA[Input stream content of HTTP response or {@code null} by default.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContent} or
             {@link #setContent}]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getContentType} or
             {@link #setContentType}">
      <doc>
      <![CDATA[Content type of HTTP response or {@code null} by default.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getContentType} or
             {@link #setContentType}]]>
      </doc>
    </field>
    <field name="statusCode" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getStatusCode} or
             {@link #setStatusCode}">
      <doc>
      <![CDATA[Status code of HTTP response or {@code 200} by default.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getStatusCode} or
             {@link #setStatusCode}]]>
      </doc>
    </field>
    <field name="headerNames" type="java.util.ArrayList&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getHeaderNames} or
             {@link #setHeaderNames}">
      <doc>
      <![CDATA[List of header names of HTTP response (empty array list by default).

 @deprecated (scheduled to be made private in 1.6) Use {@link #getHeaderNames} or
             {@link #setHeaderNames}]]>
      </doc>
    </field>
    <field name="headerValues" type="java.util.ArrayList&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getHeaderValues} or
             {@link #setHeaderValues}">
      <doc>
      <![CDATA[List of header values of HTTP response (empty array list by default).

 @deprecated (scheduled to be made private in 1.6) Use {@link #getHeaderValues} or
             {@link #setHeaderValues}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Mock for {@link LowLevelHttpResponse}.

 <p>
 Implementation is not thread-safe.
 </p>

 @author Yaniv Inbar
 @since 1.3]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.http.MockLowLevelHttpResponse -->
</package>
<package name="com.google.api.client.testing.json">
  <!-- start class com.google.api.client.testing.json.AbstractJsonGeneratorTest -->
  <class name="AbstractJsonGeneratorTest" extends="TestCase"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonGeneratorTest" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newFactory" return="com.google.api.client.json.JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="testGenerateEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="testGenerateFeed"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Abstract test case for {@link JsonGenerator}.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonGeneratorTest -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonGeneratorTest.Entry -->
  <class name="AbstractJsonGeneratorTest.Entry" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="title" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonGeneratorTest.Entry -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonGeneratorTest.Feed -->
  <class name="AbstractJsonGeneratorTest.Feed" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonGeneratorTest.Feed"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="entries" type="java.util.Collection&lt;com.google.api.client.testing.json.AbstractJsonGeneratorTest.Entry&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonGeneratorTest.Feed -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest -->
  <class name="AbstractJsonParserTest" extends="TestCase"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newFactory" return="com.google.api.client.json.JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="testParse_empty"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParse_emptyMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParse_emptyGenericJson"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_partialEmpty"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParseEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="testParser_partialEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParseFeed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="testParseEntryAsMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipToKey_missingEmpty"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipToKey_missing"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipToKey_found"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipToKey_startWithFieldName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipChildren_string"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipChildren_object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipChildren_array"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testNextToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testCurrentToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_numberTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testToFromString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_anyType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_arrayType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_collectionType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_mapType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_hashmapForMapType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_wildCardType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_integerTypeVariableType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_intArrayTypeVariableType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_doubleListTypeVariableType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_floatMapTypeVariableType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_treemapForTypeVariableType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_nullValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_enumValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_typeVariablesPassAround"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_stringArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_intArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_emptyArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_partialEmptyArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_num"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_string"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_null"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_bool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Abstract test case for {@link JsonParser}.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.A -->
  <class name="AbstractJsonParserTest.A" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.A"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="map" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.A -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.AnyType -->
  <class name="AbstractJsonParserTest.AnyType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.AnyType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="arr" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="bool" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="num" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="obj" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="str" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="nul" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.AnyType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.ArrayType -->
  <class name="AbstractJsonParserTest.ArrayType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.ArrayType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="integerArr" type="java.lang.Integer[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.ArrayType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.CollectionOfCollectionType -->
  <class name="AbstractJsonParserTest.CollectionOfCollectionType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.CollectionOfCollectionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="arr" type="java.util.LinkedList&lt;java.util.LinkedList&lt;java.lang.String&gt;&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.CollectionOfCollectionType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.DoubleListTypeVariableType -->
  <class name="AbstractJsonParserTest.DoubleListTypeVariableType" extends="com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType&lt;java.util.List&lt;java.lang.Double&gt;&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.DoubleListTypeVariableType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.DoubleListTypeVariableType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.E -->
  <class name="AbstractJsonParserTest.E" extends="java.lang.Enum&lt;com.google.api.client.testing.json.AbstractJsonParserTest.E&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.testing.json.AbstractJsonParserTest.E[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.testing.json.AbstractJsonParserTest.E"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.E -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.Entry -->
  <class name="AbstractJsonParserTest.Entry" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.Entry"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="title" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.Entry -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.EnumValue -->
  <class name="AbstractJsonParserTest.EnumValue" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.EnumValue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="value" type="com.google.api.client.testing.json.AbstractJsonParserTest.E"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="otherValue" type="com.google.api.client.testing.json.AbstractJsonParserTest.E"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="nullValue" type="com.google.api.client.testing.json.AbstractJsonParserTest.E"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.EnumValue -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.Feed -->
  <class name="AbstractJsonParserTest.Feed" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.Feed"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="entries" type="java.util.Collection&lt;com.google.api.client.testing.json.AbstractJsonParserTest.Entry&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.Feed -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.FloatMapTypeVariableType -->
  <class name="AbstractJsonParserTest.FloatMapTypeVariableType" extends="com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType&lt;java.util.Map&lt;java.lang.String, java.lang.Float&gt;&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.FloatMapTypeVariableType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.FloatMapTypeVariableType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.IntArrayTypeVariableType -->
  <class name="AbstractJsonParserTest.IntArrayTypeVariableType" extends="com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType&lt;int[]&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.IntArrayTypeVariableType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.IntArrayTypeVariableType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.IntegerTypeVariableType -->
  <class name="AbstractJsonParserTest.IntegerTypeVariableType" extends="com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType&lt;java.lang.Integer&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.IntegerTypeVariableType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.IntegerTypeVariableType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.MapOfMapType -->
  <class name="AbstractJsonParserTest.MapOfMapType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.MapOfMapType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="value" type="java.util.Map[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.MapOfMapType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.NumberTypes -->
  <class name="AbstractJsonParserTest.NumberTypes" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.NumberTypes"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.NumberTypes -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.NumberTypesAsString -->
  <class name="AbstractJsonParserTest.NumberTypesAsString" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.NumberTypesAsString"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.NumberTypesAsString -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.StringNullValue -->
  <class name="AbstractJsonParserTest.StringNullValue" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.StringNullValue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="arr2" type="java.lang.String[][]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="arr" type="java.lang.String[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="value" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.StringNullValue -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariablesPassedAround -->
  <class name="AbstractJsonParserTest.TypeVariablesPassedAround" extends="com.google.api.client.testing.json.AbstractJsonParserTest.X&lt;java.util.LinkedList&lt;java.lang.String&gt;&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.TypeVariablesPassedAround"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariablesPassedAround -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType -->
  <class name="AbstractJsonParserTest.TypeVariableType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.TypeVariableType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="arr" type="T[][]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="list" type="java.util.LinkedList&lt;java.util.LinkedList&lt;T&gt;&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="nullValue" type="T"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="value" type="T"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.WildCardTypes -->
  <class name="AbstractJsonParserTest.WildCardTypes" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.WildCardTypes"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="lower" type="java.util.Collection[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="map" type="java.util.Map&lt;java.lang.String, ?&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="mapInWild" type="java.util.Collection&lt;? super java.util.TreeMap&lt;java.lang.String, ? extends java.lang.Integer&gt;&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="mapUpper" type="java.util.Map&lt;java.lang.String, ? extends java.lang.Integer&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="simple" type="java.util.Collection[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="upper" type="java.util.Collection[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.WildCardTypes -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.X -->
  <class name="AbstractJsonParserTest.X" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.X"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.X -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.Y -->
  <class name="AbstractJsonParserTest.Y" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.Y"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.Y -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.Z -->
  <class name="AbstractJsonParserTest.Z" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.Z"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.Z -->
</package>
<package name="com.google.api.client.util">
  <!-- start class com.google.api.client.util.ArrayMap -->
  <class name="ArrayMap" extends="java.util.AbstractMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="ArrayMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new instance of an array map with initial capacity of zero. Equivalent to calling the
 default constructor, except without the need to specify the type parameters. For example:
 {@code ArrayMap<String, String> map = ArrayMap.create();}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Returns a new instance of an array map of the given initial capacity. For example: {@code
 ArrayMap<String, String> map = ArrayMap.create(8);}.]]>
      </doc>
    </method>
    <method name="of" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyValuePairs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns a new instance of an array map of the given key value pairs in alternating order. For
 example: {@code ArrayMap<String, String> map = ArrayMap.of("key1", "value1", "key2", "value2",
 ...);}.
 <p>
 WARNING: there is no compile-time checking of the {@code keyValuePairs} parameter to ensure
 that the keys or values have the correct type, so if the wrong type is passed in, any problems
 will occur at runtime. Also, there is no checking that the keys are unique, which the caller
 must ensure is true.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of key-value pairs set.]]>
      </doc>
    </method>
    <method name="getKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the key at the given index or {@code null} if out of bounds.]]>
      </doc>
    </method>
    <method name="getValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the value at the given index or {@code null} if out of bounds.]]>
      </doc>
    </method>
    <method name="set" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Sets the key/value mapping at the given index, overriding any existing key/value mapping.
 <p>
 There is no checking done to ensure that the key does not already exist. Therefore, this method
 is dangerous to call unless the caller can be certain the key does not already exist in the
 map.

 @return previous value or {@code null} for none
 @throws IndexOutOfBoundsException if index is negative]]>
      </doc>
    </method>
    <method name="set" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Sets the value at the given index, overriding any existing value mapping.

 @return previous value or {@code null} for none
 @throws IndexOutOfBoundsException if index is negative or {@code >=} size]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds the key/value mapping at the end of the list. Behaves identically to {@code set(size(),
 key, value)}.

 @throws IndexOutOfBoundsException if index is negative]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Removes the key/value mapping at the given index, or ignored if the index is out of bounds.

 @return previous value or {@code null} for none]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns whether there is a mapping for the given key.]]>
      </doc>
    </method>
    <method name="getIndexOfKey" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns the index of the given key or {@code -1} if there is no such key.]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value set for the given key or {@code null} if there is no such mapping or if the
 mapping value is {@code null}.]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Sets the value for the given key, overriding any existing value.

 @return previous value or {@code null} for none]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes the key-value pair of the given key, or ignore if the key cannot be found.

 @return previous value or {@code null} for none]]>
      </doc>
    </method>
    <method name="trim"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Trims the internal array storage to minimize memory usage.]]>
      </doc>
    </method>
    <method name="ensureCapacity"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="minCapacity" type="int"/>
      <doc>
      <![CDATA[Ensures that the capacity of the internal arrays is at least a given capacity.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Memory-efficient map of keys to values with list-style random-access semantics.

 <p>
 Supports null keys and values. Conceptually, the keys and values are stored in a simpler array in
 order to minimize memory use and provide for fast access to a key/value at a certain index (for
 example {@link #getKey(int)}). However, traditional mapping operations like {@link #get(Object)}
 and {@link #put(Object, Object)} are slower because they need to look up all key/value pairs in
 the worst case.
 </p>

 <p>
 Implementation is not thread-safe. For a thread-safe choice instead use an implementation of
 {@link ConcurrentMap}.
 </p>

 @param <K> the type of keys maintained by this map
 @param <V> the type of mapped values

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.ArrayMap -->
  <!-- start class com.google.api.client.util.ArrayValueMap -->
  <class name="ArrayValueMap" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayValueMap" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param destination destination object whose fields must be set, or destination map whose values
        must be set]]>
      </doc>
    </constructor>
    <method name="setValues"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the fields of the given object using the values collected during parsing of the object's
 fields.]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <param name="arrayComponentType" type="java.lang.Class&lt;?&gt;"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Puts an additional value for the given field, accumulating values on repeated calls on the same
 field.

 @param field field
 @param arrayComponentType array component type
 @param value value]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <param name="arrayComponentType" type="java.lang.Class&lt;?&gt;"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Puts an additional value for the given key name, accumulating values on repeated calls on the
 same key name.

 @param keyName key name
 @param arrayComponentType array component type
 @param value value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Collects the array values of a key/value data object, writing the fields or map values only after
 all values have been collected.

 <p>
 The typical application for this is when parsing JSON or XML when the value type is known to be
 an array. It stores the values in a collection during the parsing, and only when the parsing of
 an object is finished does it convert the collection into an array and stores it.
 </p>

 <p>
 Use {@link #put(String, Class, Object)} when the destination object is a map with string keys and
 whose values accept an array of objects. Use {@link #put(Field, Class, Object)} when setting the
 value of a field using reflection, assuming its type accepts an array of objects. One can
 potentially use both {@code put} methods for example on an instance of {@link GenericData}.
 </p>

 <p>
 Implementation is not thread-safe. For a thread-safe choice instead use an implementation of
 {@link ConcurrentMap}.
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.ArrayValueMap -->
  <!-- start class com.google.api.client.util.Base64 -->
  <class name="Base64" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="encode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <doc>
      <![CDATA[Similar to {@link #encode(byte[])} but returns a byte array instead of instantiating a String.
 This is more efficient if you're working with I/O streams and have large data sets to encode.


 @param source The data to convert
 @return The Base64-encoded data as a byte[] (of ASCII characters)
 @throws NullPointerException if source array is null
 @since 2.3.1]]>
      </doc>
    </method>
    <method name="encode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Similar to {@link #encode(byte[], int, int)} but returns a byte array instead of instantiating
 a String. This is more efficient if you're working with I/O streams and have large data sets to
 encode.


 @param source The data to convert
 @param off Offset in array where conversion should begin
 @param len Length of data to convert
 @return The Base64-encoded data as a String
 @throws NullPointerException if source array is null
 @throws IllegalArgumentException if source array, offset, or length are invalid
 @since 2.3.1]]>
      </doc>
    </method>
    <method name="decode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Low-level access to decoding ASCII characters in the form of a byte array. <strong>Ignores
 GUNZIP option, if it's set.</strong> This is not generally a recommended method, although it is
 used internally as part of the decoding process. Special case: if len = 0, an empty array is
 returned. Still, if you need more speed and reduced memory footprint (and aren't gzipping),
 consider this method.

 @param source The Base64 encoded data
 @return decoded data
 @since 2.3.1]]>
      </doc>
    </method>
    <method name="decode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Low-level access to decoding ASCII characters in the form of a byte array. <strong>Ignores
 GUNZIP option, if it's set.</strong> This is not generally a recommended method, although it is
 used internally as part of the decoding process. Special case: if len = 0, an empty array is
 returned. Still, if you need more speed and reduced memory footprint (and aren't gzipping),
 consider this method.

 @param source The Base64 encoded data
 @param off The offset of where to begin decoding
 @param len The length of characters to decode
 @return decoded data
 @throws java.io.IOException If bogus characters exist in source data
 @since 1.3]]>
      </doc>
    </method>
  </class>
  <!-- end class com.google.api.client.util.Base64 -->
  <!-- start class com.google.api.client.util.ClassInfo -->
  <class name="ClassInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="com.google.api.client.util.ClassInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="underlyingClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the class information for the given underlying class.

 @param underlyingClass underlying class or {@code null} for {@code null} result
 @return class information or {@code null} for {@code null} input]]>
      </doc>
    </method>
    <method name="getUnderlyingClass" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the underlying class.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getFieldInfo" return="com.google.api.client.util.FieldInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the information for the given {@link FieldInfo#getName()}.

 @param name {@link FieldInfo#getName()} or {@code null}
 @return field information or {@code null} for none]]>
      </doc>
    </method>
    <method name="getField" return="java.lang.reflect.Field"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the field for the given {@link FieldInfo#getName()}.

 @param name {@link FieldInfo#getName()} or {@code null}
 @return field or {@code null} for none]]>
      </doc>
    </method>
    <method name="isEnum" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the underlying class is an enum.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable sorted set (with any possible {@code null} member first) of
 {@link FieldInfo#getName() names}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Parses class information to determine data key name/value pairs associated with the class.

 <p>
 Implementation is thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.ClassInfo -->
  <!-- start class com.google.api.client.util.Data -->
  <class name="Data" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Data"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="nullOf" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the single instance of the magic object that represents the "null" value for the given
 Java class (including array or enum).

 @param objClass class of the object needed
 @return magic object instance that represents the "null" value (not Java {@code null})
 @throws IllegalArgumentException if unable to create a new instance]]>
      </doc>
    </method>
    <method name="isNull" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns whether the given object is the magic object that represents the null value of its
 class.

 @param object object or {@code null}
 @return whether it is the magic null value or {@code false} for {@code null} input]]>
      </doc>
    </method>
    <method name="mapOf" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the map to use for the given data that is treated as a map from string key to some
 value.

 <p>
 If the input is {@code null}, it returns an empty map. If the input is a map, it simply returns
 the input. Otherwise, it will create a map view using reflection that is backed by the object,
 so that any changes to the map will be reflected on the object. The map keys of that map view
 are based on the {@link Key} annotation, and null is not a possible map value, although the
 magic null instance is possible (see {@link #nullOf(Class)} and {@link #isNull(Object)}).
 Iteration order of the data keys is based on the sorted (ascending) key names of the declared
 fields. Note that since the map view is backed by the object, and that the object may change,
 many methods in the map view must recompute the field values using reflection, for example
 {@link Map#size()} must check the number of non-null fields.
 </p>

 @param data any key value data, represented by an object or a map, or {@code null}
 @return key/value map to use]]>
      </doc>
    </method>
    <method name="clone" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Returns a deep clone of the given key/value data, such that the result is a completely
 independent copy.
 <p>
 This should not be used directly in the implementation of {@code Object.clone()}. Instead use
 {@link #deepCopy(Object, Object)} for that purpose.
 </p>
 <p>
 Final fields cannot be changed and therefore their value won't be copied.
 </p>

 @param data key/value data object or map to clone or {@code null} for a {@code null} return
        value
 @return deep clone or {@code null} for {@code null} input]]>
      </doc>
    </method>
    <method name="deepCopy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.lang.Object"/>
      <param name="dest" type="java.lang.Object"/>
      <doc>
      <![CDATA[Makes a deep copy of the given source object into the destination object that is assumed to be
 constructed using {@code Object.clone()}.

 <p>
 Example usage of this method in {@code Object.clone()}:
 </p>

 <pre>
  &#64;Override
  public MyObject clone() {
    try {
      &#64;SuppressWarnings("unchecked")
      MyObject result = (MyObject) super.clone();
      Data.deepCopy(this, result);
      return result;
    } catch (CloneNotSupportedException e) {
      throw new IllegalStateException(e);
    }
  }
 </pre>
 <p>
 Final fields cannot be changed and therefore their value won't be copied.
 </p>

 @param src source object (non-primitive as defined by {@link Data#isPrimitive(Type)}
 @param dest destination object of identical type as source object, and any contained arrays
        must be the same length]]>
      </doc>
    </method>
    <method name="isPrimitive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns whether the given type is one of the supported primitive classes like number and
 date/time, or is a wildcard of one.

 @param type type or {@code null} for {@code false} result
 @return whether it is a primitive]]>
      </doc>
    </method>
    <method name="isValueOfPrimitiveType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns whether to given value is {@code null} or its class is primitive as defined by
 {@link Data#isPrimitive(Type)}.]]>
      </doc>
    </method>
    <method name="parsePrimitiveValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="stringValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses the given string value based on the given primitive type.
 <p>
 Types are parsed as follows:
 <ul>
 <li>{@code null} or is assignable from {@link String} (like {@link Object}): no parsing</li>
 <li>{@code char} or {@link Character}: {@link String#charAt(int) String.charAt}(0) (requires
 length to be exactly 1)</li>
 <li>{@code boolean} or {@link Boolean}: {@link Boolean#valueOf(String)}</li>
 <li>{@code byte} or {@link Byte}: {@link Byte#valueOf(String)}</li>
 <li>{@code short} or {@link Short}: {@link Short#valueOf(String)}</li>
 <li>{@code int} or {@link Integer}: {@link Integer#valueOf(String)}</li>
 <li>{@code long} or {@link Long}: {@link Long#valueOf(String)}</li>
 <li>{@code float} or {@link Float}: {@link Float#valueOf(String)}</li>
 <li>{@code double} or {@link Double}: {@link Double#valueOf(String)}</li>
 <li>{@link BigInteger}: {@link BigInteger#BigInteger(String) BigInteger(String)}</li>
 <li>{@link BigDecimal}: {@link BigDecimal#BigDecimal(String) BigDecimal(String)}</li>
 <li>{@link DateTime}: {@link DateTime#parseRfc3339(String)}</li>
 </ul>
 Note that this may not be the right behavior for some use cases.

 @param type primitive type or {@code null} to parse as a string
 @param stringValue string value to parse or {@code null} for {@code null} result
 @return parsed object or {@code null} for {@code null} input
 @throws IllegalArgumentException if the given class is not a primitive class]]>
      </doc>
    </method>
    <method name="newCollectionInstance" return="java.util.Collection&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a new collection instance for the given type.
 <p>
 Creates a new collection instance specified for the first input collection class that matches
 as follows:
 <ul>
 <li>{@code null} or an array or assignable from {@link ArrayList} (like {@link List} or
 {@link Collection} or {@link Object}): returns an {@link ArrayList}</li>
 <li>assignable from {@link HashSet}: returns a {@link HashSet}</li>
 <li>assignable from {@link TreeSet}: returns a {@link TreeSet}</li>
 <li>else: calls {@link Types#newInstance(Class)}</li>
 </ul>

 @param type type or {@code null} for {@link ArrayList}.
 @return new collection instance
 @throws ClassCastException if result is does not extend {@link Collection}]]>
      </doc>
    </method>
    <method name="newMapInstance" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new instance of a map based on the given field class.
 <p>
 Creates a new map instance specified for the first input map class that matches as follows:
 </p>
 <ul>
 <li>{@code null} or assignable from {@link ArrayMap} (like {@link Map} or {@link Object}):
 returns an {@link ArrayMap}</li>
 <li>assignable from {@link TreeMap} (like {@link SortedMap}): returns a {@link TreeMap}</li>
 <li>else: calls {@link Types#newInstance(Class)}</li>
 </ul>

 @param mapClass field class
 @throws ClassCastException if result is does not extend {@link Map}]]>
      </doc>
    </method>
    <method name="resolveWildcardTypeOrTypeVariable" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.util.List&lt;java.lang.reflect.Type&gt;"/>
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Aggressively resolves the given type in such a way that the resolved type is not a wildcard
 type or a type variable, returning {@code Object.class} if the type variable cannot be
 resolved.

 @param context context list, ordering from least specific to most specific type context, for
        example container class and then its field
 @param type type or {@code null} for {@code null} result
 @return resolved type (which may be class, parameterized type, or generic array type, but not
         wildcard type or type variable) or {@code null} for {@code null} input]]>
      </doc>
    </method>
    <field name="NULL_BOOLEAN" type="java.lang.Boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Boolean}.]]>
      </doc>
    </field>
    <field name="NULL_STRING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link String}.]]>
      </doc>
    </field>
    <field name="NULL_CHARACTER" type="java.lang.Character"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Character}.]]>
      </doc>
    </field>
    <field name="NULL_BYTE" type="java.lang.Byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Byte}.]]>
      </doc>
    </field>
    <field name="NULL_SHORT" type="java.lang.Short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Short}.]]>
      </doc>
    </field>
    <field name="NULL_INTEGER" type="java.lang.Integer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Integer}.]]>
      </doc>
    </field>
    <field name="NULL_FLOAT" type="java.lang.Float"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Float}.]]>
      </doc>
    </field>
    <field name="NULL_LONG" type="java.lang.Long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Long}.]]>
      </doc>
    </field>
    <field name="NULL_DOUBLE" type="java.lang.Double"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Double}.]]>
      </doc>
    </field>
    <field name="NULL_BIG_INTEGER" type="java.math.BigInteger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link BigInteger}.]]>
      </doc>
    </field>
    <field name="NULL_BIG_DECIMAL" type="java.math.BigDecimal"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link BigDecimal}.]]>
      </doc>
    </field>
    <field name="NULL_DATE_TIME" type="com.google.api.client.util.DateTime"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link DateTime}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Utilities for working with key/value data based on the {@link Key} annotation.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Data -->
  <!-- start class com.google.api.client.util.DateTime -->
  <class name="DateTime" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="DateTime" type="java.util.Date, java.util.TimeZone"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="java.util.Date"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="long, java.lang.Integer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="boolean, long, java.lang.Integer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the date/time value expressed as the number of milliseconds since the Unix epoch.

 <p>
 If the time zone is specified, this value is normalized to UTC, so to format this date/time
 value, the time zone shift has to be applied.
 </p>

 @since 1.5]]>
      </doc>
    </method>
    <method name="isDateOnly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this is a date-only value.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getTimeZoneShift" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the time zone shift from UTC in minutes or {@code null} for local time zone.

 @since 1.5]]>
      </doc>
    </method>
    <method name="toStringRfc3339" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Formats the value as an RFC 3339 date/time string.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="parseRfc3339" return="com.google.api.client.util.DateTime"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="NumberFormatException" type="java.lang.NumberFormatException"/>
      <doc>
      <![CDATA[Parses an RFC 3339 date/time value.]]>
      </doc>
    </method>
    <field name="value" type="long"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getValue()}">
      <doc>
      <![CDATA[Date/time value expressed as the number of ms since the Unix epoch.

  If the time zone is specified, this value is normalized to UTC, so to format this date/time
 value, the time zone shift has to be applied.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getValue()}]]>
      </doc>
    </field>
    <field name="dateOnly" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #isDateOnly()}">
      <doc>
      <![CDATA[Specifies whether this is a date-only value.

 @deprecated (scheduled to be made private in 1.6) Use {@link #isDateOnly()}]]>
      </doc>
    </field>
    <field name="tzShift" type="java.lang.Integer"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getTimeZoneShift()}">
      <doc>
      <![CDATA[Time zone shift from UTC in minutes. If {@code null}, no time zone is set, and the time is
 always interpreted as local time.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getTimeZoneShift()}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Immutable representation of a date with an optional time and an optional time zone based on RFC
 3339.

 <p>
 Implementation is immutable and therefore thread-safe.
 </p>

 <p>
 Upgrade warning: in prior version 1.4 this class was not final, but now it is final to ensure its
 immutability.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.DateTime -->
  <!-- start class com.google.api.client.util.FieldInfo -->
  <class name="FieldInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="com.google.api.client.util.FieldInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumValue" type="java.lang.Enum&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the field information for the given enum value.

 @param enumValue enum value
 @return field information
 @throws IllegalArgumentException if the enum value has no value annotation
 @since 1.4]]>
      </doc>
    </method>
    <method name="of" return="com.google.api.client.util.FieldInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the field information for the given field.

 @param field field or {@code null} for {@code null} result
 @return field information or {@code null} if the field has no {@link #name} or for {@code null}
         input]]>
      </doc>
    </method>
    <method name="getField" return="java.lang.reflect.Field"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the data key name associated with the field for a non-enum-constant with a {@link Key}
 annotation, or data key value associated with the enum constant with a {@link Value} annotation
 or {@code null} for an enum constant with a {@link NullValue} annotation.

 <p>
 This string is interned.
 </p>

 @since 1.4]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field's type.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getGenericType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field's generic type, which is a class, parameterized type, generic array type, or
 type variable, but not a wildcard type.

 @since 1.4]]>
      </doc>
    </method>
    <method name="isFinal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the field is final.

 @since 1.4]]>
      </doc>
    </method>
    <method name="isPrimitive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the field is primitive as defined by {@link Data#isPrimitive(Type)}.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value of the field in the given object instance using reflection.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets to the given value of the field in the given object instance using reflection.
 <p>
 If the field is final, it checks that value being set is identical to the existing value.]]>
      </doc>
    </method>
    <method name="getClassInfo" return="com.google.api.client.util.ClassInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class information of the field's declaring class.]]>
      </doc>
    </method>
    <method name="enumValue" return="T extends java.lang.Enum&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFieldValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value of the given field in the given object instance using reflection.]]>
      </doc>
    </method>
    <method name="setFieldValue"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets to the given value of the given field in the given object instance using reflection.
 <p>
 If the field is final, it checks that value being set is identical to the existing value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Parses field information to determine data key name/value pair associated with the field.

 <p>
 Implementation is thread-safe.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.FieldInfo -->
  <!-- start class com.google.api.client.util.GenericData -->
  <class name="GenericData" extends="java.util.AbstractMap&lt;java.lang.String, java.lang.Object&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="GenericData"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.Object"/>
    </method>
    <method name="put" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the given field value (may be {@code null}) for the given field name. Any existing value
 for the field will be overwritten. It may be more slightly more efficient than
 {@link #put(String, Object)} because it avoids accessing the field's original value.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends java.lang.String, ?&gt;"/>
    </method>
    <method name="remove" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;java.lang.String, java.lang.Object&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.util.GenericData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Makes a "deep" clone of the generic data, in which the clone is completely independent of the
 original.]]>
      </doc>
    </method>
    <method name="getUnknownKeys" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the map of unknown data key name to value.

 @since 1.5]]>
      </doc>
    </method>
    <method name="setUnknownKeys"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="unknownKeys" type="com.google.api.client.util.ArrayMap&lt;java.lang.String, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Sets the map of unknown data key name to value.

 @since 1.5]]>
      </doc>
    </method>
    <field name="unknownFields" type="com.google.api.client.util.ArrayMap&lt;java.lang.String, java.lang.Object&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private in 1.6) Use {@link #getUnknownKeys()}">
      <doc>
      <![CDATA[Map of unknown fields.

 @deprecated (scheduled to be made private in 1.6) Use {@link #getUnknownKeys()}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic data that stores all unknown data key name/value pairs.

 <p>
 Subclasses can declare fields for known data keys using the {@link Key} annotation. Each field
 can be of any visibility (private, package private, protected, or public) and must not be static.
 {@code null} unknown data key names are not allowed, but {@code null} data values are allowed.
 </p>

 <p>
 Iteration order of the data keys is based on the sorted (ascending) key names of the declared
 fields, followed by the iteration order of all of the unknown data key name/value pairs.
 </p>

 <p>
 Implementation is not thread-safe. For a thread-safe choice instead use an implementation of
 {@link ConcurrentMap}.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.GenericData -->
  <!-- start class com.google.api.client.util.Key -->
  <class name="Key"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Use this annotation to specify that a field is a data key, optionally providing the data key name
 to use.
 <p>
 If the data key name is not specified, the default is the Java field's name. For example:
 </p>

 <pre><code>
  public class A {

    // uses data key name of "dataKeyNameMatchesFieldName"
    &#64;Key
    public String dataKeyNameMatchesFieldName;

    // uses data key name of "some_other_name"
    &#64;Key("some_other_name")
    private String dataKeyNameIsOverriden;

    // not a data key
    private String notADataKey;
  }
 </code></pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Key -->
  <!-- start class com.google.api.client.util.NullValue -->
  <class name="NullValue"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Use this annotation to specify that an enum constant is the "null" data value to use for
 {@link Data#nullOf(Class)}.
 <p>
 See {@link Value} for an example.
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.NullValue -->
  <!-- start class com.google.api.client.util.Strings -->
  <class name="Strings" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="toBytesUtf8" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a new byte array that is the result of encoding the given string into a sequence of
 bytes using the {@code "UTF-8"} charset.

 @param string given string
 @return resultant byte array
 @since 1.2]]>
      </doc>
    </method>
    <method name="fromBytesUtf8" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns a new {@code String} by decoding the specified array of bytes using the {@code "UTF-8"}
 charset.

 <p>
 The length of the new {@code String} is a function of the charset, and hence may not be equal
 to the length of the byte array.
 </p>

 @param bytes bytes to be decoded into characters
 @return resultant string
 @since 1.2]]>
      </doc>
    </method>
    <field name="VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Current version of the Google API Client Library for Java.

 @since 1.3]]>
      </doc>
    </field>
    <field name="LINE_SEPARATOR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Line separator to use for this OS, i.e. {@code "\n"} or {@code "\r\n"}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Utilities for strings.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Strings -->
  <!-- start class com.google.api.client.util.Types -->
  <class name="Types" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSuperParameterizedType" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="superClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the parameterized type that is or extends the given type that matches the given super
 class.

 <p>
 For example, if the input type is {@code HashMap<String,Integer>} and the input super class is
 {@code Map.class}, it will return the extended parameterized type {@link Map}, but which
 retains the actual type information from the original {@code HashMap}.
 </p>

 @param type class or parameterized type
 @param superClass super class
 @return matching parameterized type or {@code null}]]>
      </doc>
    </method>
    <method name="isAssignableToOrFrom" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classToCheck" type="java.lang.Class&lt;?&gt;"/>
      <param name="anotherClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns whether a class is either assignable to or from another class.

 @param classToCheck class to check
 @param anotherClass another class]]>
      </doc>
    </method>
    <method name="newInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a new instance of the given class by invoking its default constructor.

 <p>
 The given class must be public and must have a public default constructor, and must not be an
 array or an interface or be abstract. If an enclosing class, it must be static.
 </p>]]>
      </doc>
    </method>
    <method name="isArray" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns whether the given type is an array.]]>
      </doc>
    </method>
    <method name="getArrayComponentType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns the component type of the given array type, assuming {@link #isArray(Type)}.

 <p>
 Return type will either be class, parameterized type, generic array type, or type variable, but
 not a wildcard type.
 </p>

 @throws ClassCastException if {@link #isArray(Type)} is false]]>
      </doc>
    </method>
    <method name="getRawClass" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameterType" type="java.lang.reflect.ParameterizedType"/>
      <doc>
      <![CDATA[Returns the raw class for the given parameter type as defined in
 {@link ParameterizedType#getRawType()}.

 @param parameterType parameter type
 @return raw class]]>
      </doc>
    </method>
    <method name="getBound" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wildcardType" type="java.lang.reflect.WildcardType"/>
      <doc>
      <![CDATA[Returns the only bound of the given wildcard type.

 @param wildcardType wildcard type
 @return only bound or {@code Object.class} for none]]>
      </doc>
    </method>
    <method name="resolveTypeVariable" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.util.List&lt;java.lang.reflect.Type&gt;"/>
      <param name="typeVariable" type="java.lang.reflect.TypeVariable&lt;?&gt;"/>
      <doc>
      <![CDATA[Resolves the actual type of the given type variable that comes from a field type based on the
 given context list.
 <p>
 In case the type variable can be resolved partially, it will return the partially resolved type
 variable.
 </p>

 @param context context list, ordering from least specific to most specific type context, for
        example container class and then its field
 @param typeVariable type variable
 @return resolved or partially resolved actual type (type variable, class, parameterized type,
         or generic array type, but not wildcard type) or {@code null} if unable to resolve at
         all]]>
      </doc>
    </method>
    <method name="getRawArrayComponentType" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.util.List&lt;java.lang.reflect.Type&gt;"/>
      <param name="componentType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns the raw array component type to use -- for example for the first parameter of
 {@link Array#newInstance(Class, int)} -- for the given component type.

 @param context context list, ordering from least specific to most specific type context, for
        example container class and then its field
 @param componentType array component type or {@code null} for {@code Object.class} result
 @return raw array component type]]>
      </doc>
    </method>
    <method name="getIterableParameter" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterableType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns the type parameter of {@link Iterable} that is assignable from the given iterable type.

 <p>
 For example, for the type {@code ArrayList<Integer>} -- or for a class that extends {@code
 ArrayList<Integer>} -- it will return {@code Integer}.
 </p>

 @param iterableType iterable type (must extend {@link Iterable})
 @return type parameter, which may be any type]]>
      </doc>
    </method>
    <method name="getMapValueParameter" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns the value type parameter of {@link Map} that is assignable from the given map type.

 <p>
 For example, for the type {@code Map<String, Integer>} -- or for a class that extends {@code
 Map<String, Integer>} -- it will return {@code Integer}.
 </p>

 @param mapType map type (must extend {@link Map})
 @return type parameter, which may be any type]]>
      </doc>
    </method>
    <method name="iterableOf" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns an iterable for an input iterable or array value.

 <p>
 If the input value extends {@link Iterable}, it will just return the input value. Otherwise, it
 will return an iterable that can handle arrays of primitive and non-primitive component type.
 </p>

 @param value iterable (extends {@link Iterable}) or array value
 @return iterable]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
      <param name="componentType" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new array of the given component type (possibly a Java primitive) that is a copy of
 the content of the given collection.

 @param collection collection
 @param componentType component type (possibly a Java primitive)
 @return new array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utilities for working with Java types.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Types -->
  <!-- start class com.google.api.client.util.Value -->
  <class name="Value"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Use this annotation to specify that an enum constant is a string data value, optionally providing
 the string data value to use.
 <p>
 If the string data value is not specified, the default is the Java field's name. For example:
 </p>

 <pre>
  public enum A {

    // value is "USE_FIELD_NAME"
    &#64;Value
    USE_FIELD_NAME,

    // value is "specifiedValue"
    &#64;Value("specifiedValue")
    USE_SPECIFIED_VALUE, 

    // value is null
    &#64;NullValue
    NULL_VALUE

    // not a value
    NOT_A_VALUE
  }
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Value -->
</package>
<package name="com.google.api.client.util.escape">
  <!-- start class com.google.api.client.util.escape.CharEscapers -->
  <class name="CharEscapers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="escapeUri" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Escapes the string value so it can be safely included in URIs. For details on escaping URIs,
 see section 2.4 of <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>.

 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the
 same.
 <li>The special characters ".", "-", "*", and "_" remain the same.
 <li>The space character " " is converted into a plus sign "+".
 <li>All other characters are converted into one or more bytes using UTF-8 encoding and each
 byte is then represented by the 3-character string "%XY", where "XY" is the two-digit,
 uppercase, hexadecimal representation of the byte value.
 </ul>

 <p>
 <b>Note</b>: Unlike other escapers, URI escapers produce uppercase hexadecimal sequences. From
 <a href="http://www.ietf.org/rfc/rfc3986.txt"> RFC 3986</a>:<br> <i>"URI producers and
 normalizers should use uppercase hexadecimal digits for all percent-encodings."</i>

 <p>
 This escaper has identical behavior to (but is potentially much faster than):
 <ul>
 <li>{@link java.net.URLEncoder#encode(String, String)} with the encoding name "UTF-8"
 </ul>]]>
      </doc>
    </method>
    <method name="decodeUri" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Percent-decodes a US-ASCII string into a Unicode string. UTF-8 encoding is used to determine
 what characters are represented by any consecutive sequences of the form "%<i>XX</i>".

 <p>
 This replaces each occurrence of '+' with a space, ' '. So this method should not be used for
 non application/x-www-form-urlencoded strings such as host and path.

 @param uri a percent-encoded US-ASCII string
 @return a Unicode string]]>
      </doc>
    </method>
    <method name="escapeUriPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Escapes the string value so it can be safely included in URI path segments. For details on
 escaping URIs, see section 2.4 of <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.

 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the
 same.
 <li>The unreserved characters ".", "-", "~", and "_" remain the same.
 <li>The general delimiters "@" and ":" remain the same.
 <li>The subdelimiters "!", "$", "&amp;", "'", "(", ")", "*", ",", ";", and "=" remain the same.
 <li>The space character " " is converted into %20.
 <li>All other characters are converted into one or more bytes using UTF-8 encoding and each
 byte is then represented by the 3-character string "%XY", where "XY" is the two-digit,
 uppercase, hexadecimal representation of the byte value.
 </ul>

 <p>
 <b>Note</b>: Unlike other escapers, URI escapers produce uppercase hexadecimal sequences. From
 <a href="http://www.ietf.org/rfc/rfc3986.txt"> RFC 3986</a>:<br> <i>"URI producers and
 normalizers should use uppercase hexadecimal digits for all percent-encodings."</i>]]>
      </doc>
    </method>
    <method name="escapeUriQuery" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Escapes the string value so it can be safely included in URI query string segments. When the
 query string consists of a sequence of name=value pairs separated by &amp;, the names and
 values should be individually encoded. If you escape an entire query string in one pass with
 this escaper, then the "=" and "&amp;" characters used as separators will also be escaped.

 <p>
 This escaper is also suitable for escaping fragment identifiers.

 <p>
 For details on escaping URIs, see section 2.4 of <a
 href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.

 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the
 same.
 <li>The unreserved characters ".", "-", "~", and "_" remain the same.
 <li>The general delimiters "@" and ":" remain the same.
 <li>The path delimiters "/" and "?" remain the same.
 <li>The subdelimiters "!", "$", "'", "(", ")", "*", ",", and ";", remain the same.
 <li>The space character " " is converted into %20.
 <li>The equals sign "=" is converted into %3D.
 <li>The ampersand "&amp;" is converted into %26.
 <li>All other characters are converted into one or more bytes using UTF-8 encoding and each
 byte is then represented by the 3-character string "%XY", where "XY" is the two-digit,
 uppercase, hexadecimal representation of the byte value.
 </ul>

 <p>
 <b>Note</b>: Unlike other escapers, URI escapers produce uppercase hexadecimal sequences. From
 <a href="http://www.ietf.org/rfc/rfc3986.txt"> RFC 3986</a>:<br> <i>"URI producers and
 normalizers should use uppercase hexadecimal digits for all percent-encodings."</i>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility functions for dealing with {@code CharEscaper}s, and some commonly used {@code
 CharEscaper} instances.

 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.escape.CharEscapers -->
  <!-- start class com.google.api.client.util.escape.Escaper -->
  <class name="Escaper" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Escaper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="escape" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string.

 <p>
 Note that this method may treat input characters differently depending on the specific escaper
 implementation.
 <ul>
 <li>{@link UnicodeEscaper} handles <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>
 correctly, including surrogate character pairs. If the input is badly formed the escaper should
 throw {@link IllegalArgumentException}.
 </ul>

 @param string the literal string to be escaped
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if {@code string} contains badly formed UTF-16 or cannot be
         escaped for any other reason]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that converts literal text into a format safe for inclusion in a particular context
 (such as an XML document). Typically (but not always), the inverse process of "unescaping" the
 text is performed automatically by the relevant parser.

 <p>
 For example, an XML escaper would convert the literal string {@code "Foo<Bar>"} into {@code
 "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from being confused with an XML tag. When the
 resulting XML document is parsed, the parser API will return this text as the original literal
 string {@code "Foo<Bar>"}.

 <p>
 An {@code Escaper} instance is required to be stateless, and safe when used concurrently by
 multiple threads.

 <p>
 Several popular escapers are defined as constants in the class {@link CharEscapers}.

 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.escape.Escaper -->
  <!-- start class com.google.api.client.util.escape.PercentEscaper -->
  <class name="PercentEscaper" extends="com.google.api.client.util.escape.UnicodeEscaper"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PercentEscaper" type="java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a URI escaper with the specified safe characters and optional handling of the space
 character.

 @param safeChars a non null string specifying additional safe characters for this escaper (the
        ranges 0..9, a..z and A..Z are always safe and should not be specified here)
 @param plusForSpace true if ASCII space should be escaped to {@code +} rather than {@code %20}
 @throws IllegalArgumentException if any of the parameters were invalid]]>
      </doc>
    </constructor>
    <method name="nextEscapeIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="end" type="int"/>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="escape" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Escapes the given Unicode code point in UTF-8.]]>
      </doc>
    </method>
    <field name="SAFECHARS_URLENCODER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string of safe characters that mimics the behavior of {@link java.net.URLEncoder}.]]>
      </doc>
    </field>
    <field name="SAFEPATHCHARS_URLENCODER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string of characters that do not need to be encoded when used in URI path segments, as
 specified in RFC 3986. Note that some of these characters do need to be escaped when used in
 other parts of the URI.]]>
      </doc>
    </field>
    <field name="SAFEQUERYSTRINGCHARS_URLENCODER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string of characters that do not need to be encoded when used in URI query strings, as
 specified in RFC 3986. Note that some of these characters do need to be escaped when used in
 other parts of the URI.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A {@code UnicodeEscaper} that escapes some set of Java characters using the URI percent encoding
 scheme. The set of safe characters (those which remain unescaped) can be specified on
 construction.

 <p>
 For details on escaping URIs for use in web pages, see section 2.4 of <a
 href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.

 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the
 same.
 <li>Any additionally specified safe characters remain the same.
 <li>If {@code plusForSpace} was specified, the space character " " is converted into a plus sign
 "+".
 <li>All other characters are converted into one or more bytes using UTF-8 encoding and each byte
 is then represented by the 3-character string "%XY", where "XY" is the two-digit, uppercase,
 hexadecimal representation of the byte value.
 </ul>

 <p>
 RFC 2396 specifies the set of unreserved characters as "-", "_", ".", "!", "~", "*", "'", "(" and
 ")". It goes on to state:

 <p>
 <i>Unreserved characters can be escaped without changing the semantics of the URI, but this
 should not be done unless the URI is being used in a context that does not allow the unescaped
 character to appear.</i>

 <p>
 For performance reasons the only currently supported character encoding of this class is UTF-8.

 <p>
 <b>Note</b>: This escaper produces uppercase hexadecimal sequences. From <a
 href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>:<br> <i>"URI producers and normalizers
 should use uppercase hexadecimal digits for all percent-encodings."</i>

 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.escape.PercentEscaper -->
  <!-- start class com.google.api.client.util.escape.UnicodeEscaper -->
  <class name="UnicodeEscaper" extends="com.google.api.client.util.escape.Escaper"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnicodeEscaper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="escape" return="char[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Returns the escaped form of the given Unicode code point, or {@code null} if this code point
 does not need to be escaped. When called as part of an escaping operation, the given code point
 is guaranteed to be in the range {@code 0 <= cp <= Character#MAX_CODE_POINT}.

 <p>
 If an empty array is returned, this effectively strips the input character from the resulting
 text.

 <p>
 If the character does not need to be escaped, this method should return {@code null}, rather
 than an array containing the character representation of the code point. This enables the
 escaping algorithm to perform more efficiently.

 <p>
 If the implementation of this method cannot correctly handle a particular code point then it
 should either throw an appropriate runtime exception or return a suitable replacement
 character. It must never silently discard invalid input as this may constitute a security risk.

 @param cp the Unicode code point to escape if necessary
 @return the replacement characters, or {@code null} if no escaping was needed]]>
      </doc>
    </method>
    <method name="nextEscapeIndex" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <doc>
      <![CDATA[Scans a sub-sequence of characters from a given {@link CharSequence}, returning the index of
 the next character that requires escaping.

 <p>
 <b>Note:</b> When implementing an escaper, it is a good idea to override this method for
 efficiency. The base class implementation determines successive Unicode code points and invokes
 {@link #escape(int)} for each of them. If the semantics of your escaper are such that code
 points in the supplementary range are either all escaped or all unescaped, this method can be
 implemented more efficiently using {@link CharSequence#charAt(int)}.

 <p>
 Note however that if your escaper does not escape characters in the supplementary range, you
 should either continue to validate the correctness of any surrogate characters encountered or
 provide a clear warning to users that your escaper does not validate its input.

 <p>
 See {@link PercentEscaper} for an example.

 @param csq a sequence of characters
 @param start the index of the first character to be scanned
 @param end the index immediately after the last character to be scanned
 @throws IllegalArgumentException if the scanned sub-sequence of {@code csq} contains invalid
         surrogate pairs]]>
      </doc>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string.

 <p>
 If you are escaping input in arbitrary successive chunks, then it is not generally safe to use
 this method. If an input string ends with an unmatched high surrogate character, then this
 method will throw {@link IllegalArgumentException}. You should ensure your input is valid <a
 href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> before calling this method.

 @param string the literal string to be escaped
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if invalid surrogate characters are encountered]]>
      </doc>
    </method>
    <method name="escapeSlow" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string, starting at the given index. This method is
 called by the {@link #escape(String)} method when it discovers that escaping is required. It is
 protected to allow subclasses to override the fastpath escaping function to inline their
 escaping test.

 <p>
 This method is not reentrant and may only be invoked by the top level {@link #escape(String)}
 method.

 @param s the literal string to be escaped
 @param index the index to start escaping from
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if invalid surrogate characters are encountered]]>
      </doc>
    </method>
    <method name="codePointAt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="seq" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="end" type="int"/>
      <doc>
      <![CDATA[Returns the Unicode code point of the character at the given index.

 <p>
 Unlike {@link Character#codePointAt(CharSequence, int)} or {@link String#codePointAt(int)} this
 method will never fail silently when encountering an invalid surrogate pair.

 <p>
 The behaviour of this method is as follows:
 <ol>
 <li>If {@code index >= end}, {@link IndexOutOfBoundsException} is thrown.
 <li><b>If the character at the specified index is not a surrogate, it is returned.</b>
 <li>If the first character was a high surrogate value, then an attempt is made to read the next
 character.
 <ol>
 <li><b>If the end of the sequence was reached, the negated value of the trailing high surrogate
 is returned.</b>
 <li><b>If the next character was a valid low surrogate, the code point value of the high/low
 surrogate pair is returned.</b>
 <li>If the next character was not a low surrogate value, then {@link IllegalArgumentException}
 is thrown.
 </ol>
 <li>If the first character was a low surrogate value, {@link IllegalArgumentException} is
 thrown.
 </ol>

 @param seq the sequence of characters from which to decode the code point
 @param index the index of the first character to decode
 @param end the index beyond the last valid character to decode
 @return the Unicode code point for the given index or the negated value of the trailing high
         surrogate character at the end of the sequence]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@link Escaper} that converts literal text into a format safe for inclusion in a particular
 context (such as an XML document). Typically (but not always), the inverse process of
 "unescaping" the text is performed automatically by the relevant parser.

 <p>
 For example, an XML escaper would convert the literal string {@code "Foo<Bar>"} into {@code
 "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from being confused with an XML tag. When the
 resulting XML document is parsed, the parser API will return this text as the original literal
 string {@code "Foo<Bar>"}.

 <p>
 As there are important reasons, including potential security issues, to handle Unicode correctly
 if you are considering implementing a new escaper you should favor using UnicodeEscaper wherever
 possible.

 <p>
 A {@code UnicodeEscaper} instance is required to be stateless, and safe when used concurrently by
 multiple threads.

 <p>
 Several popular escapers are defined as constants in the class {@link CharEscapers}. To create
 your own escapers extend this class and implement the {@link #escape(int)} method.

 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.escape.UnicodeEscaper -->
</package>
<package name="com.google.api.client.xml">
  <!-- start class com.google.api.client.xml.GenericXml -->
  <class name="GenericXml" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="GenericXml"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="clone" return="com.google.api.client.xml.GenericXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional XML element local name prefixed by its namespace alias -- for example {@code
 "atom:entry"} -- or {@code null} if not set.]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional namespace dictionary or {@code null} if not set.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic XML data that stores all unknown key name/value pairs.

 <p>
 Each data key name maps into the name of the XPath expression value for the XML element,
 attribute, or text content (using {@code "text()"}). Subclasses can declare fields for known XML
 content using the {@link Key} annotation. Each field can be of any visibility (private, package
 private, protected, or public) and must not be static. {@code null} unknown data key names are
 not allowed, but {@code null} data values are allowed.
 </p>

 <p>
 Implementation is not thread-safe. For a thread-safe choice instead use an implementation of
 {@link ConcurrentMap}.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.GenericXml -->
  <!-- start class com.google.api.client.xml.Xml -->
  <class name="Xml" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createSerializer" return="XmlSerializer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new XML serializer.

 @throws IllegalArgumentException if encountered an {@link XmlPullParserException}]]>
      </doc>
    </method>
    <method name="createParser" return="XmlPullParser"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Returns a new XML pull parser.]]>
      </doc>
    </method>
    <method name="toStringOf" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value pairs.
 <p>
 It will make up something for the element name and XML namespaces. If those are known, it is
 better to use {@link XmlNamespaceDictionary#toStringOf(String, Object)}.

 @param element element data object of key/value pairs ({@link GenericXml}, {@link Map}, or any
        object with public fields)]]>
      </doc>
    </method>
    <method name="parseElement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="XmlPullParser"/>
      <param name="destination" type="java.lang.Object"/>
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <param name="customizeParser" type="com.google.api.client.xml.Xml.CustomizeParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parses an XML element using the given XML pull parser into the given destination object.

 <p>
 Requires the the current event be {@link XmlPullParser#START_TAG} (skipping any initial
 {@link XmlPullParser#START_DOCUMENT}) of the element being parsed. At normal parsing
 completion, the current event will either be {@link XmlPullParser#END_TAG} of the element being
 parsed, or the {@link XmlPullParser#START_TAG} of the requested {@code atom:entry}.
 </p>

 @param parser XML pull parser
 @param destination optional destination object to parser into or {@code null} to ignore XML
        content
 @param namespaceDictionary XML namespace dictionary to store unknown namespaces
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <doc>
    <![CDATA[XML utilities.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.Xml -->
  <!-- start class com.google.api.client.xml.Xml.CustomizeParser -->
  <class name="Xml.CustomizeParser" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Xml.CustomizeParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stopBeforeStartTag" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespace" type="java.lang.String"/>
      <param name="localName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether to stop parsing when reaching the start tag of an XML element before it has
 been processed. Only called if the element is actually being processed. By default, returns
 {@code false}, but subclasses may override.

 @param namespace XML element's namespace URI
 @param localName XML element's local name]]>
      </doc>
    </method>
    <method name="stopAfterEndTag" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespace" type="java.lang.String"/>
      <param name="localName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether to stop parsing when reaching the end tag of an XML element after it has been
 processed. Only called if the element is actually being processed. By default, returns {@code
 false}, but subclasses may override.

 @param namespace XML element's namespace URI
 @param localName XML element's local name]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Customizes the behavior of XML parsing. Subclasses may override any methods they need to
 customize behavior.

 <p>
 Implementation has no fields and therefore thread-safe, but sub-classes are not necessarily
 thread-safe.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.Xml.CustomizeParser -->
  <!-- start class com.google.api.client.xml.XmlNamespaceDictionary -->
  <class name="XmlNamespaceDictionary" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="XmlNamespaceDictionary"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAliasForUri" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the namespace alias (or {@code ""} for the default namespace) for the given namespace
 URI.

 @param uri namespace URI
 @since 1.3]]>
      </doc>
    </method>
    <method name="getUriForAlias" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the namespace URI for the given namespace alias (or {@code ""} for the default
 namespace).

 @param alias namespace alias (or {@code ""} for the default namespace)
 @since 1.3]]>
      </doc>
    </method>
    <method name="getAliasToUriMap" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodified set of map entries for the map from namespace alias (or {@code ""} for
 the default namespace) to namespace URI.

 @since 1.3]]>
      </doc>
    </method>
    <method name="getUriToAliasMap" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodified set of map entries for the map from namespace URI to namespace alias (or
 {@code ""} for the default namespace).

 @since 1.3]]>
      </doc>
    </method>
    <method name="set" return="com.google.api.client.xml.XmlNamespaceDictionary"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="java.lang.String"/>
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a namespace of the given alias and URI.

 <p>
 If the uri is {@code null}, the namespace alias will be removed. Similarly, if the alias is
 {@code null}, the namespace URI will be removed. Otherwise, if the alias is already mapped to a
 different URI, it will be remapped to the new URI. Similarly, if a URI is already mapped to a
 different alias, it will be remapped to the new alias.
 </p>

 @param alias alias or {@code null} to remove the namespace URI
 @param uri namespace URI or {@code null} to remove the namespace alias
 @return this namespace dictionary
 @since 1.3]]>
      </doc>
    </method>
    <method name="toStringOf" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementName" type="java.lang.String"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value pairs.

 @param element element data object ({@link GenericXml}, {@link Map}, or any object with public
        fields)
 @param elementName optional XML element local name prefixed by its namespace alias -- for
        example {@code "atom:entry"} -- or {@code null} to make up something]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <param name="elementNamespaceUri" type="java.lang.String"/>
      <param name="elementLocalName" type="java.lang.String"/>
      <param name="element" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value pairs.

 @param element element data object ({@link GenericXml}, {@link Map}, or any object with public
        fields)
 @param elementNamespaceUri XML namespace URI or {@code null} for no namespace
 @param elementLocalName XML local name
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <param name="elementName" type="java.lang.String"/>
      <param name="element" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value pairs.

 @param element element data object ({@link GenericXml}, {@link Map}, or any object with public
        fields)
 @param elementName XML element local name prefixed by its namespace alias
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thread-safe XML namespace dictionary that provides a one-to-one map of namespace alias to URI.

 <p>
 Implementation is thread-safe. For maximum efficiency, applications should use a single
 globally-shared instance of the XML namespace dictionary.
 </p>

 <p>
 A namespace alias is uniquely mapped to a single namespace URI, and a namespace URI is uniquely
 mapped to a single namespace alias. In other words, it is not possible to have duplicates.
 </p>

 <p>
 Sample usage:
 </p>

 <pre>{@code
  static final XmlNamespaceDictionary DICTIONARY = new XmlNamespaceDictionary()
      .set("", "http://www.w3.org/2005/Atom")
      .set("activity", "http://activitystrea.ms/spec/1.0/")
      .set("georss", "http://www.georss.org/georss")
      .set("media", "http://search.yahoo.com/mrss/")
      .set("thr", "http://purl.org/syndication/thread/1.0");
}</pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.XmlNamespaceDictionary -->
</package>
<package name="com.google.api.client.xml.atom">
  <!-- start class com.google.api.client.xml.atom.AbstractAtomFeedParser -->
  <class name="AbstractAtomFeedParser" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractAtomFeedParser"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.6) Use {@link
             #AbstractAtomFeedParser(XmlNamespaceDictionary, XmlPullParser, InputStream, Class)}">
      <doc>
      <![CDATA[@deprecated (scheduled to be removed in 1.6) Use {@link
             #AbstractAtomFeedParser(XmlNamespaceDictionary, XmlPullParser, InputStream, Class)}]]>
      </doc>
    </constructor>
    <constructor name="AbstractAtomFeedParser" type="com.google.api.client.xml.XmlNamespaceDictionary, XmlPullParser, java.io.InputStream, java.lang.Class&lt;T&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param namespaceDictionary XML namespace dictionary
 @param parser XML pull parser to use
 @param inputStream input stream to read
 @param feedClass feed class to parse
 @since 1.5]]>
      </doc>
    </constructor>
    <method name="getParser" return="XmlPullParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the XML pull parser to use.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the input stream to read.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getFeedClass" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the feed class to parse.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getNamespaceDictionary" return="com.google.api.client.xml.XmlNamespaceDictionary"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the XML namespace dictionary.

 @since 1.5]]>
      </doc>
    </method>
    <method name="parseFeed" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parse the feed and return a new parsed instance of the feed type. This method can be skipped if
 all you want are the items.

 @throws IOException I/O exception
 @throws XmlPullParserException XML pull parser exception]]>
      </doc>
    </method>
    <method name="parseNextEntry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parse the next item in the feed and return a new parsed instance of the item type. If there is
 no item to parse, it will return {@code null} and automatically close the parser (in which case
 there is no need to call {@link #close()}.

 @throws IOException I/O exception
 @throws XmlPullParserException XML pull parser exception]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes the underlying parser.]]>
      </doc>
    </method>
    <method name="parseEntryInternal" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parses a single entry.

 @return object representing the entry
 @throws IOException I/O exception
 @throws XmlPullParserException XML pull parser exception]]>
      </doc>
    </method>
    <field name="parser" type="XmlPullParser"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getParser}">
      <doc>
      <![CDATA[XML pull parser to use.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getParser}]]>
      </doc>
    </field>
    <field name="inputStream" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getInputStream}">
      <doc>
      <![CDATA[Input stream to read.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getInputStream}]]>
      </doc>
    </field>
    <field name="feedClass" type="java.lang.Class&lt;T&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getFeedClass}">
      <doc>
      <![CDATA[Feed class to parse.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getFeedClass}]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be made private final in 1.6) Use {@link #getNamespaceDictionary}">
      <doc>
      <![CDATA[XML namespace dictionary.

 @deprecated (scheduled to be made private final in 1.6) Use {@link #getNamespaceDictionary}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Abstract base class for an Atom feed parser when the feed type is known in advance.

 <p>
 Implementation is not thread-safe.
 </p>

 @param <T> feed type
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AbstractAtomFeedParser -->
  <!-- start class com.google.api.client.xml.atom.Atom -->
  <class name="Atom" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkContentType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks the given content type matches the Atom content type specified in {@link #CONTENT_TYPE}.

 @throws IllegalArgumentException if content type doesn't match]]>
      </doc>
    </method>
    <field name="ATOM_NAMESPACE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Atom namespace.]]>
      </doc>
    </field>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Atom content type.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[@since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.Atom -->
</package>

</api>
